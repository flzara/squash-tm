<?xml version="1.0" encoding="UTF-8"?>
<!--

        This file is part of the Squashtest platform.
        Copyright (C) Henix, henix.fr

        See the NOTICE file distributed with this work for additional
        information regarding copyright ownership.

        This is free software: you can redistribute it and/or modify
        it under the terms of the GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        this software is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU Lesser General Public License for more details.

        You should have received a copy of the GNU Lesser General Public License
        along with this software.  If not, see <http://www.gnu.org/licenses/>.

-->
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-2.0.xsd">


  <changeSet id="tm-1.19.0" author="cholc">
    <comment>Update TM database version number</comment>
    <update tableName="CORE_CONFIG">
      <column name="VALUE" value="1.19.0"/>
      <where>STR_KEY = 'squashtest.tm.database.version'</where>
    </update>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-400-info-list-item" author="cholc">
    <comment>Adds a colour field to info list items</comment>
    <addColumn tableName="INFO_LIST_ITEM">
      <column name="COLOUR" type="VARCHAR(7)">
        <constraints nullable="true"/>
      </column>
    </addColumn>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-400-custom-field-option" author="cholc">
    <comment>Adds a colour field to custom field options</comment>
    <addColumn tableName="CUSTOM_FIELD_OPTION">
      <column name="COLOUR" type="VARCHAR(7)">
        <constraints nullable="true"/>
      </column>
    </addColumn>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-409-iteration-test-suite-remove-constraint" author="cholc">
    <comment>To drop an unique constraint, you need the constraint's name, which we don't have, so here we copy the
      column and delete the original
    </comment>

    <addColumn tableName="ITERATION_TEST_SUITE">
      <column name="TEST_SUITE_ID_TEMP" type="BIGINT">
        <constraints nullable="true" unique="false"/>
      </column>
    </addColumn>

    <dropForeignKeyConstraint baseTableName="ITERATION_TEST_SUITE" constraintName="fk_iteration_test_suite_suite"/>

    <update tableName="ITERATION_TEST_SUITE">
      <column name="TEST_SUITE_ID_TEMP" type="BIGINT" valueComputed="TEST_SUITE_ID"/>
    </update>

    <dropColumn columnName="TEST_SUITE_ID" tableName="ITERATION_TEST_SUITE"/>

    <renameColumn columnDataType="BIGINT" newColumnName="TEST_SUITE_ID" oldColumnName="TEST_SUITE_ID_TEMP"
                  tableName="ITERATION_TEST_SUITE"/>

    <addNotNullConstraint tableName="ITERATION_TEST_SUITE" columnName="TEST_SUITE_ID" columnDataType="BIGINT"/>

    <addForeignKeyConstraint baseColumnNames="TEST_SUITE_ID"
                             baseTableName="ITERATION_TEST_SUITE"
                             constraintName="fk_iteration_test_suite_suite"
                             referencedColumnNames="ID"
                             referencedTableName="TEST_SUITE"/>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-409-iteration-test-suite-order" author="cholc">
    <comment>add an order to iterations' test suites</comment>
    <addColumn tableName="ITERATION_TEST_SUITE">
      <column name="ITERATION_TEST_SUITE_ORDER" type="INT">
      </column>
    </addColumn>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-409-iteration-test-suite-order-generation" author="cholc">
    <comment>will compute the order of the test suites in the iterations, should work for all databases</comment>
    <sql>
      UPDATE ITERATION_TEST_SUITE ITS
      SET
      ITERATION_TEST_SUITE_ORDER = (SELECT
      SUB_QUERY.ORDER_DEF
      FROM
      (SELECT
      ITS1.ITERATION_ID AS I_ID,
      ITS1.TEST_SUITE_ID AS TS_ID,
      (COUNT(*) - 1) AS ORDER_DEF
      FROM
      ITERATION_TEST_SUITE ITS1
      INNER JOIN ITERATION_TEST_SUITE ITS2 ON ITS1.ITERATION_ID = ITS2.ITERATION_ID
      AND ITS1.TEST_SUITE_ID >= ITS2.TEST_SUITE_ID
      GROUP BY ITS1.ITERATION_ID , ITS1.TEST_SUITE_ID) AS SUB_QUERY
      WHERE
      SUB_QUERY.I_ID = ITS.ITERATION_ID
      AND SUB_QUERY.TS_ID = ITS.TEST_SUITE_ID);
    </sql>
    <addUniqueConstraint tableName="ITERATION_TEST_SUITE" columnNames="ITERATION_ID, ITERATION_TEST_SUITE_ORDER"
                         constraintName="uc_iteration_iteration_test_suite_order"/>
    <addNotNullConstraint tableName="ITERATION_TEST_SUITE" columnName="ITERATION_TEST_SUITE_ORDER"
                          columnDataType="INT"/>
  </changeSet>


  <changeSet id="tm-1.19.0-up-sb2-1" author="bsiri">
    <comment>Passwords are now much longer since we also store the salt.</comment>

    <modifyDataType tableName="AUTH_USER" columnName="PASSWORD" newDataType="VARCHAR(255)"/>

  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-399-infolist-items-default-colours" author="cholc">
    <comment>Requirement categories colours</comment>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#C3AB77"/>
      <where>CODE = 'CAT_TEST_REQUIREMENT'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#CDCDCD"/>
      <where>CODE = 'CAT_UNDEFINED'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#8F6057"/>
      <where>CODE = 'CAT_ERGONOMIC'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#FCCA46"/>
      <where>CODE = 'CAT_PERFORMANCE'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#233D4D"/>
      <where>CODE = 'CAT_TECHNICAL'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#094C75"/>
      <where>CODE = 'CAT_USER_STORY'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#FE7F2D"/>
      <where>CODE = 'CAT_SECURITY'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#7594CD"/>
      <where>CODE = 'CAT_FUNCTIONAL'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#BB5759"/>
      <where>CODE = 'CAT_NON_FUNCTIONAL'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#A1C181"/>
      <where>CODE = 'CAT_USE_CASE'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#619B8A"/>
      <where>CODE = 'CAT_BUSINESS'</where>
    </update>

    <comment>Test cases natures colours</comment>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#A1C181"/>
      <where>CODE = 'NAT_USER_TESTING'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#FCCA46"/>
      <where>CODE = 'NAT_PERFORMANCE_TESTING'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#FE7F2D"/>
      <where>CODE = 'NAT_SECURITY_TESTING'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#233D4D"/>
      <where>CODE = 'NAT_ATDD'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#CDCDCD"/>
      <where>CODE = 'NAT_UNDEFINED'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#7594CD"/>
      <where>CODE = 'NAT_FUNCTIONAL_TESTING'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#BB5759"/>
      <where>CODE = 'NAT_NON_FUNCTIONAL_TESTING'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#619B8A"/>
      <where>CODE = 'NAT_BUSINESS_TESTING'</where>
    </update>

    <comment>Test cases types colours</comment>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#CDCDCD"/>
      <where>CODE = 'TYP_UNDEFINED'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#5B9367"/>
      <where>CODE = 'TYP_COMPLIANCE_TESTING'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#CD533B"/>
      <where>CODE = 'TYP_CORRECTION_TESTING'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#D8A86E"/>
      <where>CODE = 'TYP_EVOLUTION_TESTING'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#F2E77E"/>
      <where>CODE = 'TYP_REGRESSION_TESTING'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#2D5635"/>
      <where>CODE = 'TYP_END_TO_END_TESTING'</where>
    </update>

    <update tableName="INFO_LIST_ITEM">
      <column name="COLOUR" value="#F2E2CE"/>
      <where>CODE = 'TYP_PARTNER_TESTING'</where>
    </update>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-453-execution-name-maxlength" author="jprioux">
    <comment>Increase max length for execution name</comment>
    <modifyDataType tableName="EXECUTION" columnName="NAME" newDataType="VARCHAR(308)"></modifyDataType>
    <addNotNullConstraint tableName="EXECUTION" columnDataType="java.sql.Types.VARCHAR(308)" columnName="NAME"/>
  </changeSet>


  <changeSet id="tm-1.19.0-SQTM-508-automation-request" author="aboittiaux">
    <comment>Create table AUTOMATION_REQUEST to Gherkin's test cases</comment>
    <createTable tableName="AUTOMATION_REQUEST">
      <column name="AUTOMATION_REQUEST_ID" type="BIGINT" autoIncrement="true">
        <constraints primaryKey="true" nullable="false"/>
      </column>
      <column name="REQUEST_STATUS" type="VARCHAR(25)" defaultValue="WORK_IN_PROGRESS">
        <constraints nullable="false"/>
      </column>
      <column name="TRANSMITTED_ON" type="DATETIME"/>
      <column name="ASSIGNED_TO" type="BIGINT"/>
      <column name="AUTOMATION_PRIORITY" type="INT"/>
      <column name="ASSIGNED_ON" type="DATETIME"/>
      <column name="TEST_CASE_ID" type="BIGINT"/>
      <column name="CREATED_BY" type="BIGINT"/>
      <column name="TRANSMITTED_BY" type="BIGINT"/>
      <column name="PROJECT_ID" type="BIGINT" remarks="fk to the host project">
        <constraints foreignKeyName="fk_automation_request_project" nullable="false" references="PROJECT(PROJECT_ID)"/>
      </column>
    </createTable>

    <createIndex tableName="AUTOMATION_REQUEST" indexName="automation_request_assigned_to_idx">
      <column name="ASSIGNED_TO"/>
    </createIndex>

    <createIndex tableName="AUTOMATION_REQUEST" indexName="automation_request_created_by_idx">
      <column name="CREATED_BY"/>
    </createIndex>

    <createIndex tableName="AUTOMATION_REQUEST" indexName="automation_request_transmitted_by_idx">
      <column name="TRANSMITTED_BY"/>
    </createIndex>

    <createIndex tableName="AUTOMATION_REQUEST" indexName="automation_request_test_case_id_idx">
      <column name="TEST_CASE_ID"/>
    </createIndex>

    <addForeignKeyConstraint baseTableName="AUTOMATION_REQUEST" baseColumnNames="ASSIGNED_TO"
                             constraintName="fk_automation_request_automation_assigned_to"
                             referencedColumnNames="PARTY_ID" referencedTableName="CORE_USER" onDelete="SET NULL"/>

    <addForeignKeyConstraint baseTableName="AUTOMATION_REQUEST" baseColumnNames="TRANSMITTED_BY"
                             constraintName="fk_automation_request_transmitted_by" referencedColumnNames="PARTY_ID"
                             referencedTableName="CORE_USER" onDelete="SET NULL"/>

    <addForeignKeyConstraint baseTableName="AUTOMATION_REQUEST" baseColumnNames="CREATED_BY"
                             constraintName="fk_automation_request_created_by" referencedColumnNames="PARTY_ID"
                             referencedTableName="CORE_USER" onDelete="SET NULL"/>

    <addForeignKeyConstraint baseTableName="AUTOMATION_REQUEST" baseColumnNames="TEST_CASE_ID"
                             constraintName="fk_automation_request_test_case" referencedColumnNames="TCLN_ID"
                             referencedTableName="TEST_CASE" onDelete="SET NULL"/>

    <addColumn tableName="TEST_CASE">
      <column name="AUTOMATABLE" type="CHAR" defaultValue="M" remarks="Y: Yes, N: No, M: Maybe"/>
    </addColumn>

  </changeSet>


  <!--  Feature SQTM-519 : the AutomationRequestLibrary -->

  <changeSet id="tm-1.19.0-SQTM-519-automation-request-library-1" author="bsiri">

    <comment>Creating the AutomationRequestLibrary</comment>

    <createTable tableName="AUTOMATION_REQUEST_LIBRARY">

      <column name="ARL_ID" type="BIGINT" autoIncrement="true" remarks="autoincremented primary key">
        <constraints primaryKey="true" nullable="false" primaryKeyName="PK_AUTOMATION_REQUEST_LIBRARY"/>
      </column>

      <column name="ATTACHMENT_LIST_ID" type="BIGINT"
              remarks="fk to the attachment list">
        <constraints nullable="true"
                     references="ATTACHMENT_LIST(ATTACHMENT_LIST_ID)"
                     foreignKeyName="fk_autorequestLib_attachment_list"/>
      </column>

    </createTable>

    <createIndex tableName="AUTOMATION_REQUEST_LIBRARY" indexName="idx_automation_request_library">
      <column name="ARL_ID"/>
    </createIndex>

  </changeSet>


  <changeSet id="tm-1.19.0-SQTM-519-automation-request-library-2" author="bsiri">
    <comment>New entries in the ACL infrastructure.</comment>

    <!--
      Magic number listing :
      * next generated ACL_CLASS.ID : 7 (AutomatedRequest)
      * next generated ACL_GROUP.ID : 10 (TestAutomationWriter)
      * CLASS_ID of test case library : 3

      Note : there is no ACL_GROUP with ID 1 and 3 for obscure reasons.

      The following script will insert the new ACL_CLASS (the automation request library) and the new ACL_GROUP
      (AutomatedTestWriter).

      Then it will batch insert in ACL_GROUP_PERMISSION, for each user profile, the same permission for automation
      requests than it enjoys for the test cases.

      Only exception is the test automation writer, which can read the test case, write the automation requests and
      that's all.

      About the PERMISSION_MASKs, the bitmaks are defined in java classes BasePermission and CustomPermission.
     -->
    <sql>
      insert into ACL_CLASS(ID, CLASSNAME) values(7,
      'org.squashtest.tm.domain.tf.automationrequest.AutomationRequestLibrary');

      insert into ACL_GROUP(ID, QUALIFIED_NAME) values(10, 'squashtest.acl.group.tm.AutomatedTestWriter');

      insert into ACL_GROUP_PERMISSION(ACL_GROUP_ID, PERMISSION_MASK, CLASS_ID)
      select AGP2.ACL_GROUP_ID, AGP2.PERMISSION_MASK, 7
      from ACL_GROUP_PERMISSION AGP2
      where CLASS_ID = 3;

      insert into ACL_GROUP_PERMISSION(ACL_GROUP_ID, CLASS_ID, PERMISSION_MASK) values
      (2, 7, 8192),
      (5, 7, 8192),
      (5, 7, 16384),
      (7, 7, 8192),
      (8, 7, 8192),
      (9, 7, 8192),
      (10, 2, 1),
      (10, 3, 1),
      (10, 4, 1),
      (10, 6, 1),
      (10, 7, 1),
      (10, 7, 2),
      (10, 7, 4),
      (10, 7, 8),
      (10, 7, 64),
      (10, 7, 256),
      (10, 7, 1024),
      (10, 7, 4096),
      (10, 7, 16384);
    </sql>


  </changeSet>


  <changeSet id="tm-1.19.0-SQTM-519-automation-request-library-3" author="bsiri">

    <comment>The automation request library content table</comment>

    <createTable tableName="AUTOMATION_REQUEST_LIBRARY_CONTENT">

      <column name="LIBRARY_ID" type="BIGINT" remarks="Foreign key to the library">
        <constraints nullable="false" foreignKeyName="fk_automation_rquest_lib_content_lib"
                     references="AUTOMATION_REQUEST_LIBRARY(ARL_ID)"/>
      </column>

      <column name="CONTENT_ID" type="BIGINT" remarks="Foreign key to the content">
        <constraints nullable="false" unique="true" foreignKeyName="fk_automation_request_lib_content_content"
                     references="AUTOMATION_REQUEST(AUTOMATION_REQUEST_ID)"/>
      </column>
    </createTable>

    <createIndex tableName="AUTOMATION_REQUEST_LIBRARY_CONTENT" indexName="idx_automation_request_lib_content_content">
      <column name="CONTENT_ID"/>
    </createIndex>

    <createIndex tableName="AUTOMATION_REQUEST_LIBRARY_CONTENT" indexName="idx_automation_request_lib_content_lib">
      <column name="LIBRARY_ID"/>
    </createIndex>

  </changeSet>


  <changeSet id="tm-1.19.0-SQTM-519-automation-request-library-4" author="bsiri">

    <comment>Add a Project fk to the AutomationRequestLibrary</comment>

    <addColumn tableName="PROJECT">
      <column name="ARL_ID" type="BIGINT" remarks="fk to the automation request library">
        <constraints foreignKeyName="fk_project_arl" references="AUTOMATION_REQUEST_LIBRARY(ARL_ID)" nullable="true"/>
      </column>
    </addColumn>

  </changeSet>


  <changeSet id="tm-1.19.0-SQTM-519-automation-request-library-5" author="bsiri">

    <comment>Create one such library for each existing projects</comment>

    <!--
    about the magic numbers, see autorequest-lib-2

    This script will create
    - one AutomationRequestLibrary per project,
    - one attachment list for them
    - wire them together,
    - the corresponding entry in ACL_OBJECT_IDENTITY
    - and finally the corresponding entries in ACL_RESPONSIBILITY_SCOPE_ENTRY

    In the following queries the IDs for the attachment lists and ARL libraries are imposed (rather than
    autogenerated) in order to simplify the operations. In particular the ARL ids are set to be the same
    than the projects they depend on.
    -->

    <sql>
      <![CDATA[
      -- create the libraries

      insert into AUTOMATION_REQUEST_LIBRARY (ARL_ID)
      select p.PROJECT_ID from PROJECT p;


      -- attachments, step 1 :
      -- create a ranking table, akin to what would ROW_NUMBER() order by id desc would say

      create table ARL_RANK as
      select alib.arl_id, count(alib2.arl_id)  as ranking
      from AUTOMATION_REQUEST_LIBRARY alib,
      AUTOMATION_REQUEST_LIBRARY alib2
      where alib.arl_id <= alib2.arl_id
      group by alib.arl_id
      order by ranking asc;


      -- attachments, step 2 :
      -- create a table that pairs library ids with predictable, consecutive attachment_list_ids using the rank
      -- calculated earlier

      create table ARL_ATTACHLIST_PAIRING as
      select arl.arl_id, (select max(al.attachment_list_id) from ATTACHMENT_LIST al) + arl.ranking as attachment_list_id
      from ARL_RANK arl;


      -- attachments, step 3 :
      -- insert the attachment lists and update fk in the automation request library
      insert into ATTACHMENT_LIST(ATTACHMENT_LIST_ID)
      select pair.attachment_list_id from ARL_ATTACHLIST_PAIRING pair;


      update AUTOMATION_REQUEST_LIBRARY arl
      set ATTACHMENT_LIST_ID = (select pair.attachment_list_id from ARL_ATTACHLIST_PAIRING pair where pair.arl_id = arl.arl_id);

      -- attachments, step 4 and final :
      -- drop the temporary tables

      drop table ARL_ATTACHLIST_PAIRING;

      drop table ARL_RANK;

      -- wire the project to the ARL library

      update PROJECT P
      set ARL_ID = PROJECT_ID;


      -- insert the acl object identities
      insert into ACL_OBJECT_IDENTITY(IDENTITY, CLASS_ID)
      select arl.arl_id, 7 from AUTOMATION_REQUEST_LIBRARY arl;


      -- add the user/team permissions in ACL_RESPONSIBILITY_SCOPE_ENTRY
      -- each user will receive the same acl_group on each arl library than on the project it depends on
      -- (this last sentence is the idea behind the auto join on acl_object_identity in this query)
      insert into ACL_RESPONSIBILITY_SCOPE_ENTRY(party_id, acl_group_id, object_identity_id)
      select distinct arse.party_id, arse.acl_group_id, arl_oid.id
      from ACL_RESPONSIBILITY_SCOPE_ENTRY arse
      inner join ACL_OBJECT_IDENTITY oid on (arse.object_identity_id = oid.id and oid.class_id = 1)
      inner join ACL_OBJECT_IDENTITY arl_oid on (oid.identity = arl_oid.identity and arl_oid.class_id = 7);

    ]]>
    </sql>


  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-519-automation-request-library-6" author="bsiri" dbms="postgresql">
    <comment>reset postgresql sequences</comment>

    <sql>
      select setval('automation_request_library_arl_id_seq', (select MAX(ARL_ID) from AUTOMATION_REQUEST_LIBRARY));
      select setval('attachment_list_attachment_list_id_seq', (select MAX(ATTACHMENT_LIST_ID) from ATTACHMENT_LIST));
      select setval('acl_object_identity_id_seq', (SELECT MAX(ID) from ACL_OBJECT_IDENTITY));
      select setval('acl_responsibility_scope_entry_id_seq', (select MAX(ID) from ACL_RESPONSIBILITY_SCOPE_ENTRY));
    </sql>

  </changeSet>


  <!--  /Feature SQTM-519 : the AutomationRequestLibrary -->

  <changeSet id="tm-1.19.0-SQTM-510-add-roles-automation" author="aboittiaux">
    <sql>
      insert into CORE_PARTY_AUTHORITY(PARTY_ID, AUTHORITY)
      select distinct cu.PARTY_ID, 'ROLE_TF_FUNCTIONAL_TESTER' from CORE_USER cu
      left join CORE_PARTY_AUTHORITY cpa on cu.PARTY_ID = cpa.PARTY_ID
      left join CORE_GROUP_MEMBER ctm on ctm.PARTY_ID = cu.PARTY_ID
      where cpa.AUTHORITY is null and ctm.GROUP_ID = 2;
    </sql>

  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-524-automation-workflow-by-project" author="jprioux">
    <comment>add a boolean in project table to activate or not the automation workflow</comment>
    <addColumn tableName="PROJECT">
      <column name="ALLOW_AUTOMATION_WORKFLOW" type="BOOLEAN"
              defaultValueBoolean="false">
        <constraints nullable="false"/>
      </column>
    </addColumn>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-create-auth-users" author="bsiri">
    <comment>add the missing entries in AUTH_USER for users that only exist in CORE_USER (eg a user created by LDAP)
    </comment>
    <sql>
      insert into AUTH_USER (login, password, active)
      select cu.LOGIN, '', cu.active
      from CORE_USER cu
      left join AUTH_USER au on cu.login = au.login
      where au.login is null;
    </sql>
  </changeSet>

  <changeSet id="tm-1.19.0-Mantis-7833" author="jprioux">
    <comment>Increase remote project id limit to 100 for redmine bt project keys</comment>
    <modifyDataType tableName="REQUIREMENT_SYNC_EXTENDER" columnName="REMOTE_PROJECT_ID" newDataType="VARCHAR(100)"/>
  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-536-autoexec-gherkin-1" author="bsiri">
    <comment>Add a flag to the test automation project that tells whether it is able to run Gherkin tests.</comment>

    <addColumn tableName="TEST_AUTOMATION_PROJECT">
      <column name="CAN_RUN_GHERKIN" type="BOOLEAN" defaultValueBoolean="false">
        <constraints nullable="false"/>
      </column>
    </addColumn>

  </changeSet>



  <!--  ============================================
      SQTM-543 : Third Party Server
  =============================================== -->

  <changeSet author="bsiri" id="tm-1.19.0-SQTM-543-third-party-server-1">
    <comment>Create the table THIRD_PARTY_SERVER</comment>

    <createTable tableName="THIRD_PARTY_SERVER" remarks="base table for third party servers">

      <column name="SERVER_ID" type="BIGINT" autoIncrement="true" remarks="primary key, autogenerated">
        <constraints primaryKey="true" nullable="false" primaryKeyName="PK_THIRD_PARTY_SERVER"/>
      </column>

      <column name="NAME" type="java.sql.Types.VARCHAR(50)" remarks="name of the server">
        <constraints nullable="false" />
      </column>

      <column name="URL" type="java.sql.Types.VARCHAR(400)" remarks="the base url">
        <constraints nullable="false" />
      </column>

      <column name="AUTH_POLICY" type="VARCHAR(30)" remarks="the policy that decides who needs to authenticate" defaultValue="USER" />

      <column name="AUTH_PROTOCOL" type="java.sql.Types.VARCHAR(30)" defaultValue="BASIC_AUTH" remarks="the protocol that should be used for that server">
        <constraints nullable="false"/>
      </column>

    </createTable>

  </changeSet>


  <changeSet author="bsiri" id="tm-1.19.0-SQTM-543-third-party-server-2">
    <comment>migrate data from table BUGTRACKER to table THIRD_PARTY_SERVER</comment>

    <sql>
      insert into THIRD_PARTY_SERVER(SERVER_ID, NAME, URL, AUTH_POLICY, AUTH_PROTOCOL)
      select BUGTRACKER_ID, NAME, URL, AUTH_POLICY, AUTH_PROTOCOL
      from BUGTRACKER;
    </sql>

  </changeSet>


  <changeSet author="bsiri" id="tm-1.19.0-SQTM-543-third-party-server-3">

    <comment>
      Drop the now unused columns from BUGTRACKER and create the FK from BUGTRACKER to THIRD_PARTY_SERVER
    </comment>

    <dropColumn tableName="BUGTRACKER" columnName="NAME"/>
    <dropColumn tableName="BUGTRACKER" columnName="URL"/>
    <dropColumn tableName="BUGTRACKER" columnName="AUTH_POLICY"/>
    <dropColumn tableName="BUGTRACKER" columnName="AUTH_PROTOCOL"/>


    <addForeignKeyConstraint baseTableName="BUGTRACKER" baseColumnNames="BUGTRACKER_ID"
                             referencedTableName="THIRD_PARTY_SERVER" referencedColumnNames="SERVER_ID"
                             constraintName="fk_bugtracker_third_party_server" onDelete="CASCADE"/>


  </changeSet>


  <changeSet author="bsiri" id="tm-1.19.0-SQTM-543-third-party-server-4">
    <comment>change the foreign key stored_credentials -> bugtracker to stored_credentials -> third_party_server </comment>

    <dropForeignKeyConstraint baseTableName="STORED_CREDENTIALS"  constraintName="fk_stored_credentials_authenticated_server"/>

    <createIndex tableName="STORED_CREDENTIALS" indexName="idx_fk_stored_credentials_authenticated_server">
      <column name="AUTHENTICATED_SERVER" type="BIGINT"/>
    </createIndex>

    <addForeignKeyConstraint constraintName="fk_stored_credentials_authenticated_server"
                             baseTableName="STORED_CREDENTIALS" baseColumnNames="AUTHENTICATED_SERVER"
                             referencedTableName="THIRD_PARTY_SERVER" referencedColumnNames="SERVER_ID"/>

  </changeSet>


  <changeSet author="bsiri" id="tm-1.19.0-SQTM-543-third-party-server-5-h2" dbms="h2">
    <comment>For H2, remove the autoincrement on bugtracker_id</comment>
    <sql>
      alter table BUGTRACKER alter column BUGTRACKER_ID BIGINT NOT NULL;
    </sql>
  </changeSet>

  <changeSet author="bsiri" id="tm-1.19.0-SQTM-534-third-party-server-5-mysql" dbms="mysql">
    <comment>For Mysql / Maria DB, remove the autoincrement on bugtracker_id</comment>

    <sql>
      set foreign_key_checks=0;
      alter table BUGTRACKER modify column BUGTRACKER_ID BIGINT not null;
      set foreign_key_checks=1;
    </sql>


  </changeSet>


  <changeSet author="bsiri" id="tm-1.19.0-SQTM-543-third-party-server-5-postgres" dbms="postgresql">
    <comment>For PostGre, remove the autoincrement on bugtracker_id and reset the sequence for third_party_server</comment>

    <sql>
      alter table BUGTRACKER alter column BUGTRACKER_ID drop default;
      drop sequence if exists bugtracker_bugtracker_id_seq;

      select setval('third_party_server_server_id_seq', (select max(SERVER_ID) from THIRD_PARTY_SERVER));
    </sql>

  </changeSet>

  <!--  ============================================
     /SQTM-543 : Third Party Server
  =============================================== -->



  <changeSet id="tm-1.19.0-SQTM-512-scm-server-management" author="jlor">
    <comment>Add new table for scm (source code management) server.</comment>

    <createTable tableName="SCM_SERVER">

      <column name="SERVER_ID" type="BIGINT" autoIncrement="false"
              remarks="The id of the scm server.">
        <constraints primaryKey="true" nullable="false"/>
      </column>

      <column name="KIND" type="VARCHAR(30)" remarks="The kind of scm server.">
        <constraints nullable="false"/>
      </column>

    </createTable>

    <addForeignKeyConstraint constraintName="fk_scm_server_third_party_server"
      baseTableName="SCM_SERVER" baseColumnNames="SERVER_ID"
       referencedTableName="THIRD_PARTY_SERVER" referencedColumnNames="SERVER_ID" onDelete="CASCADE"/>

  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-512-scm-repository-management" author="jlor">
    <comment>Add new table for scm (source code management) repository.</comment>

    <createTable tableName="SCM_REPOSITORY">

      <column name="SCM_REPOSITORY_ID" type="BIGINT" autoIncrement="true"
              remarks="The auto-generated id of the scm repository.">
        <constraints primaryKey="true" nullable="false"/>
      </column>
      <column name="SERVER_ID" type="BIGINT" remarks="The foreign key to the related SCM_SEVER">
        <constraints nullable="false" foreignKeyName="fk_scm_repository_scm_server"
                     references="SCM_SERVER(SERVER_ID)"/>
      </column>

      <column name="NAME" type="VARCHAR(255)" remarks="The unique name of the repository.">
        <constraints unique="true" nullable="false"/>
      </column>

      <column name="REPOSITORY_PATH" type="VARCHAR(255)"
              remarks="The absolute path to the local repository on the local server.">
        <constraints nullable="false"/>
      </column>

      <column name="WORKING_FOLDER_PATH" type="VARCHAR(255)" remarks="The relative path of the working folder in which SquashTM will push."/>

      <column name="WORKING_BRANCH" type="VARCHAR(255)" remarks="The name of the working branch on which SquashTM will push.">
        <constraints nullable="false"/>
      </column>

    </createTable>

  </changeSet>

  <changeSet id="tm-1.19.0-SQTM-512-project-scm-repository-binding" author="jlor">
    <comment>Add foreign key in project table to reference a scm (source code management) repository.</comment>

    <addColumn tableName="PROJECT">
      <column name="SCM_REPOSITORY_ID" type="BIGINT">
        <constraints foreignKeyName="fk_project_scm_repository" references="SCM_REPOSITORY(SCM_REPOSITORY_ID)"/>
      </column>
    </addColumn>

  </changeSet>

  <changeSet id="tm-1.19.0-fixing-postgresql-index" author="jthebault" dbms="postgresql">
    <sql>
      create index idx_fk_acl_grp_permission_acl_grp on acl_group_permission(acl_group_id);
      create index idx_fk_acl_obj_id_acl_class on acl_object_identity(class_id);
      create index idx_fk_action_test_step_attachment_list on action_test_step(attachment_list_id);
      create index idx_fk_arse_party on acl_responsibility_scope_entry(party_id);
      create index idx_fk_attachment_att_list on attachment(attachment_list_id);
      create index idx_fk_attachment_content on attachment(content_id);
      create index idx_fk_audit_event_requirement_version on requirement_audit_event(req_version_id);
      create index idx_fk_auto_exec_auto_test on automated_execution_extender(test_id);
      create index idx_fk_auto_exec_exec on automated_execution_extender(master_execution_id);
      create index idx_fk_auto_exec_suite on automated_execution_extender(suite_id);
      create index idx_fk_automated_test_project on automated_test(project_id);
      create index idx_fk_automation_request_project on automation_request(project_id);
      create index idx_fk_autorequestlib_attachment_list on automation_request_library(attachment_list_id);
      create index idx_fk_axis_column_chart_column on chart_axis_column(chart_column_id);
      create index idx_fk_bugtracker_binding_bugtracker on bugtracker_binding(bugtracker_id);
      create index idx_fk_bugtracker_binding_project on bugtracker_binding(project_id);
      create index idx_fk_bugtracker_project_bugtracker_binding on bugtracker_project(bugtracker_binding_id);
      create index idx_fk_call_step_called_test_case on call_test_step(called_test_case_id);
      create index idx_fk_call_step_dataset on call_test_step(called_dataset);
      create index idx_fk_camp_iter_campaign on campaign_iteration(campaign_id);
      create index idx_fk_camp_iter_iteration on campaign_iteration(iteration_id);
      create index idx_fk_camp_test_plan_item_dataset on campaign_test_plan_item(dataset_id);
      create index idx_fk_camp_tp_campaign on campaign_test_plan_item(campaign_id);
      create index idx_fk_camp_tp_testcase on campaign_test_plan_item(test_case_id);
      create index idx_fk_camp_tp_user on campaign_test_plan_item(user_id);
      create index idx_fk_camplib_attachment_list on campaign_library(attachment_list_id);
      create index idx_fk_campnode_attachment_list on campaign_library_node(attachment_list_id);
      create index idx_fk_cf_option_cf on custom_field_option(cf_id);
      create index idx_fk_cfb_bound_project on custom_field_binding(bound_project_id);
      create index idx_fk_cfb_cf on custom_field_binding(cf_id);
      create index idx_fk_cfb_render_loc_cfb on custom_field_rendering_location(cfb_id);
      create index idx_fk_cfv_cf_binding on custom_field_value(cfb_id);
      create index idx_fk_cfv_option_cfv on custom_field_value_option(cfv_id);
      create index idx_fk_chart_axis_chart_query on chart_axis_column(query_id);
      create index idx_fk_chart_bindind_chart_definition_chart_id on custom_report_chart_binding(chart_id);
      create index idx_fk_chart_bindind_custom_report_dashboard_crd_id on custom_report_chart_binding(crd_id);
      create index idx_fk_chart_bindind_report_definition_report_id on custom_report_report_binding(report_id);
      create index idx_fk_chart_filter_chart_column on chart_filter(chart_column_id);
      create index idx_fk_chart_filter_chart_query on chart_filter(query_id);
      create index idx_fk_chart_filter_value_chart_column on chart_filter_values(filter_id);
      create index idx_fk_chart_measure_chart_column on chart_measure_column(chart_column_id);
      create index idx_fk_chart_measure_chart_query on chart_measure_column(query_id);
      create index idx_fk_chart_owner on chart_definition(user_id);
      create index idx_fk_chart_project_scope_chart_definition on chart_project_scope(chart_id);
      create index idx_fk_chart_query on chart_definition(query_id);
      create index idx_fk_chart_scope_chart_definition on chart_scope(chart_id);
      create index idx_fk_cln_project on campaign_library_node(project_id);
      create index idx_fk_column_query on chart_column_prototype(subquery_id);
      create index idx_fk_column_role_chart_column on chart_column_role(chart_column_id);
      create index idx_fk_crl_attachment_list on custom_report_library(attachment_list_id);
      create index idx_fk_crln_custom_report_library_crl_id on custom_report_library_node(crl_id);
      create index idx_fk_dataset_param_value_dataset on dataset_param_value(dataset_id);
      create index idx_fk_dataset_param_value_param on dataset_param_value(param_id);
      create index idx_fk_dataset_test_case on dataset(test_case_id);
      create index idx_fk_df_option_dfv on denormalized_field_option(dfv_id);
      create index idx_fk_dfb_render_loc_dfb on denormalized_field_rendering_location(dfv_id);
      create index idx_fk_dfv_cfv_binding on denormalized_field_value(cfv_id);
      create index idx_fk_dfv_option_dfv on denormalized_field_value_option(dfv_id);
      create index idx_fk_disabled_exec_status_cl_id on disabled_execution_status(cl_id);
      create index idx_fk_execution_attachment_list on execution(attachment_list_id);
      create index idx_fk_execution_issue_list on execution(issue_list_id);
      create index idx_fk_execution_step__attachment_list on execution_step(attachment_list_id);
      create index idx_fk_execution_step_issue_list on execution_step(issue_list_id);
      create index idx_fk_execution_test_case on execution(tcln_id);
      create index idx_fk_executionstep_teststep on execution_step(test_step_id);
      create index idx_fk_group_member_party on core_group_member(party_id);
      create index idx_fk_grp_member_grp on core_group_member(group_id);
      create index idx_fk_info_item_list on info_list_item(list_id);
      create index idx_fk_issue_bugtracker on issue(bugtracker_id);
      create index idx_fk_issue_issue_list on issue(issue_list_id);
      create index idx_fk_iteration__attachment_list on iteration(attachment_list_id);
      create index idx_fk_iteration_test_plan_item_dataset on iteration_test_plan_item(dataset_id);
      create index idx_fk_iteration_test_suite_suite on iteration_test_suite(test_suite_id);
      create index idx_fk_itertestplan_test_case on iteration_test_plan_item(tcln_id);
      create index idx_fk_itertestplan_user on iteration_test_plan_item(user_id);
      create index idx_fk_libplugin_property_libplugin on library_plugin_binding_property(plugin_binding_id);
      create index idx_fk_milestone_binding_milestone on milestone_binding(milestone_id);
      create index idx_fk_milestone_binding_perimeter_milestone on milestone_binding_perimeter(milestone_id);
      create index idx_fk_milestone_binding_perimeter_project on milestone_binding_perimeter(project_id);
      create index idx_fk_milestone_binding_project on milestone_binding(project_id);
      create index idx_fk_milestone_owner on milestone(user_id);
      create index idx_fk_parameter_test_case on parameter(test_case_id);
      create index idx_fk_party_authority_party on core_party_authority(party_id);
      create index idx_fk_party_preference_core_party_party_id on party_preference(party_id);
      create index idx_fk_project_arl on project(arl_id);
      create index idx_fk_project_attachment_list on project(attachment_list_id);
      create index idx_fk_project_chart_definition_project_id on chart_definition(project_id);
      create index idx_fk_project_cl on project(cl_id);
      create index idx_fk_project_crl on project(crl_id);
      create index idx_fk_project_custom_report_dashboard_project_id on custom_report_dashboard(project_id);
      create index idx_fk_project_custom_report_folder_project_id on custom_report_folder(project_id);
      create index idx_fk_project_report_definition_project_id on report_definition(project_id);
      create index idx_fk_project_rl on project(rl_id);
      create index idx_fk_project_scm_repository on project(scm_repository_id);
      create index idx_fk_project_tcl on project(tcl_id);
      create index idx_fk_project_template_id on project(template_id);
      create index idx_fk_remote_sync__bugtracker__bugtracker_id on remote_synchronisation(server_id);
      create index idx_fk_remote_sync__project__project_id on remote_synchronisation(project_id);
      create index idx_fk_report_bindind_custom_report_dashboard_crd_id on custom_report_report_binding(crd_id);
      create index idx_fk_report_owner on report_definition(user_id);
      create index idx_fk_req_folder_simple_resource on requirement_folder(res_id);
      create index idx_fk_req_folder_sync_extender__remote_sync_remote_sync_id on requirement_folder_sync_extender(remote_synchronisation_id);
      create index idx_fk_req_nature on requirement_version(category);
      create index idx_fk_req_sync_extender__remote_sync_remote_sync_id on requirement_sync_extender(remote_synchronisation_id);
      create index idx_fk_req_version_link_req_version_link_type_link_type_id on requirement_version_link(link_type_id);
      create index idx_fk_reqlib_attachment_list on requirement_library(attachment_list_id);
      create index idx_fk_requirement_current_version on requirement(current_version_id);
      create index idx_fk_requirement_version_link_related_requirement_version_id on requirement_version_link(related_requirement_version_id);
      create index idx_fk_requirement_version_link_requirement_version_id on requirement_version_link(requirement_version_id);
      create index idx_fk_requirement_version_requirement on requirement_version(requirement_id);
      create index idx_fk_resource_attachment_list on resource(attachment_list_id);
      create index idx_fk_resp_scope_acl_grp on acl_responsibility_scope_entry(acl_group_id);
      create index idx_fk_resp_scope_obj_id on acl_responsibility_scope_entry(object_identity_id);
      create index idx_fk_rln_project on requirement_library_node(project_id);
      create index idx_fk_sc_auth_acl_class on acl_group_permission(class_id);
      create index idx_fk_scm_repository_scm_server on scm_repository(server_id);
      create index idx_fk_stored_credentials_user on stored_credentials(authenticated_user);
      create index idx_fk_sync_extender_requirement on requirement_sync_extender(requirement_id);
      create index idx_fk_sync_extender_server on requirement_sync_extender(server_id);
      create index idx_fk_ta_project_ta_server on test_automation_project(server_id);
      create index idx_fk_ta_project_tm_project on test_automation_project(tm_project_id);
      create index idx_fk_tc_nature on test_case(tc_nature);
      create index idx_fk_tc_type on test_case(tc_type);
      create index idx_fk_tclib_attachment_list on test_case_library(attachment_list_id);
      create index idx_fk_tcln_project on test_case_library_node(project_id);
      create index idx_fk_tcnode_attachment_list on test_case_library_node(attachment_list_id);
      create index idx_fk_team_member_team on core_team_member(team_id);
      create index idx_fk_team_member_user on core_team_member(user_id);
      create index idx_fk_test_case_ta_test on test_case(ta_test);
      create index idx_fk_test_suite_attachment_list on test_suite(attachment_list_id);
      create index idx_fk_test_suite_test_plan_item_test_plan_item on test_suite_test_plan_item(tpi_id);
      create index idx_fk_test_suite_test_plan_item_test_suite on test_suite_test_plan_item(suite_id);
      create index idx_fk_verified_req_version on requirement_version_coverage(verified_req_version_id);
      create index idx_fk_verifying_step_action_test_step on verifying_steps(test_step_id);
      create index idx_fk_verifying_step_requirement_version_coverage on verifying_steps(requirement_version_coverage_id);
      create index idx_fk_verifying_test_case on requirement_version_coverage(verifying_test_case_id);
      create index idx_milestone_camp_camp on milestone_campaign(campaign_id);
      create index idx_milestone_camp_milestone on milestone_campaign(milestone_id);
      create index idx_milestone_rqv_milestone on milestone_req_version(milestone_id);
      create index idx_milestone_rqv_rqv on milestone_req_version(req_version_id);
      create index idx_milestone_tc_milestone on milestone_test_case(milestone_id);
      create index idx_milestone_tc_tc on milestone_test_case(test_case_id);
      create index idx_proj_req_categories on project(req_categories_list);
      create index idx_proj_tc_natures on project(tc_natures_list);
      create index idx_proj_tc_types on project(tc_types_list);
      create index idx_tm_project_ta_server on project(ta_server_id);
    </sql>
  </changeSet>

  <changeSet author="aboittiaux" id="tm-1.19.0-create-automation-request">

    <sql>
      create table TC_AUTOMATION (
        TCLN_ID BIGINT,
        TM_PROJECT_ID BIGINT
      );
      insert into TC_AUTOMATION(TCLN_ID,TM_PROJECT_ID)
      select tc.TCLN_ID, tap.TM_PROJECT_ID
      from TEST_CASE tc
      inner join AUTOMATED_TEST aut on tc.TA_TEST = aut.TEST_ID
      inner join TEST_AUTOMATION_PROJECT tap on tap.TA_PROJECT_ID = aut.PROJECT_ID
      where aut.NAME is not null and tc.TC_KIND = 'STANDARD';

      update TEST_CASE set AUTOMATABLE = 'Y' where TCLN_ID in (select tca.TCLN_ID from TC_AUTOMATION tca);

      insert into AUTOMATION_REQUEST(REQUEST_STATUS, TEST_CASE_ID, PROJECT_ID) select 'AUTOMATED',tca.TCLN_ID, tca.TM_PROJECT_ID from TC_AUTOMATION tca;

      insert into AUTOMATION_REQUEST_LIBRARY_CONTENT
      (CONTENT_ID, LIBRARY_ID) select AUTOMATION_REQUEST.AUTOMATION_REQUEST_ID, AUTOMATION_REQUEST_LIBRARY.ARL_ID from AUTOMATION_REQUEST
      inner join TEST_CASE on AUTOMATION_REQUEST.TEST_CASE_ID = TEST_CASE.TCLN_ID
      inner join PROJECT on AUTOMATION_REQUEST.PROJECT_ID = PROJECT.PROJECT_ID
      inner join AUTOMATION_REQUEST_LIBRARY on AUTOMATION_REQUEST_LIBRARY.ARL_ID = PROJECT.ARL_ID;

      drop table TC_AUTOMATION;
    </sql>

  </changeSet>

  <changeSet id="tm-1.19.0-Mantis-7547" author="jprioux">
    <comment>Increase remote req id limit to 50 for jira</comment>
    <modifyDataType tableName="REQUIREMENT_SYNC_EXTENDER" columnName="REMOTE_REQ_ID" newDataType="VARCHAR(50)"/>
  </changeSet>

</databaseChangeLog>
