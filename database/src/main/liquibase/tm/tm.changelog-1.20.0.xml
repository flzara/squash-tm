<?xml version="1.0" encoding="UTF-8"?>
<!--

        This file is part of the Squashtest platform.
        Copyright (C) Henix, henix.fr

        See the NOTICE file distributed with this work for additional
        information regarding copyright ownership.

        This is free software: you can redistribute it and/or modify
        it under the terms of the GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        this software is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU Lesser General Public License for more details.

        You should have received a copy of the GNU Lesser General Public License
        along with this software.  If not, see <http://www.gnu.org/licenses/>.

-->
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-2.0.xsd">


  <changeSet id="tm-1.20.0" author="jprioux">
    <comment>Update TM database version number</comment>
    <update tableName="CORE_CONFIG">
      <column name="VALUE" value="1.20.0"/>
      <where>STR_KEY = 'squashtest.tm.database.version'</where>
    </update>
  </changeSet>

  <changeSet id="tm-1.20.0-TM-176-custom-report-custom-export" author="jlor">
    <comment>Create new object CustomExport in Custom Report Workspace</comment>

    <createTable tableName="CUSTOM_REPORT_CUSTOM_EXPORT">

      <column name="CRCE_ID" type="BIGINT" autoIncrement="true" remarks="The auto-generated id">
        <constraints primaryKey="true" nullable="false" />
      </column>

      <column name ="NAME" type="VARCHAR(255)" remarks="The name of the Custom Export"/>

      <column name="PROJECT_ID" type="BIGINT" remarks="Foreign key to the Project">
        <constraints nullable="false" foreignKeyName="fk_custom_export_project_id" references="PROJECT (PROJECT_ID)" />
      </column>

      <column name="CREATED_BY" type="VARCHAR(50)">
        <constraints nullable="false" />
      </column>

      <column name="CREATED_ON" type="DATETIME">
        <constraints nullable="false" />
      </column>

      <column name="LAST_MODIFIED_BY" type="VARCHAR(50)" defaultValue="NULL" />

      <column name="LAST_MODIFIED_ON" type="DATETIME" defaultValue="NULL" />

    </createTable>

    <createIndex tableName="CUSTOM_REPORT_CUSTOM_EXPORT" indexName="idx_fk_custom_export_project_id">
      <column name="PROJECT_ID"/>
    </createIndex>

  </changeSet>

  <changeSet id="tm-1.20.0-TM-125-use-tm-tree-structure-in-scm-repository" author="jlor">
    <comment>Add an option in Project automation settings to use the tm tree structure when transmitting test cases to a scm repository</comment>

    <addColumn tableName="PROJECT">
      <column name="USE_TREE_STRUCTURE_IN_SCM_REPO" type="BOOLEAN" defaultValueBoolean="true">
        <constraints nullable="false"/>
      </column>
    </addColumn>
  </changeSet>

  <changeSet id="tm-1.20.0-TM-220-add-missing-role-automation" author="agu">
    <comment>Add missing automation role following changeset tm-1.19.0-SQTM-510-add-roles-automation</comment>
    <sql>
      INSERT INTO CORE_PARTY_AUTHORITY(PARTY_ID, AUTHORITY)
      SELECT cpa.PARTY_ID, 'ROLE_TF_FUNCTIONAL_TESTER' from CORE_PARTY_AUTHORITY cpa
      INNER JOIN CORE_PARTY_AUTHORITY cpa2 on cpa.PARTY_ID = cpa2.PARTY_ID
      WHERE cpa.AUTHORITY = 'ROLE_TM_USER'
      GROUP BY cpa.PARTY_ID
      HAVING COUNT(cpa.PARTY_ID) = 1;
    </sql>
  </changeSet>

  <changeSet id="tm-1.20.0-TM-180" author="abo">
    <comment>Change dataType for RequirementStatus</comment>
    <sql>
      UPDATE CHART_COLUMN_PROTOTYPE SET DATA_TYPE = 'REQUIREMENT_STATUS'
      WHERE LABEL = 'REQUIREMENT_STATUS' OR LABEL = 'REQUIREMENT_VERSION_STATUS';
    </sql>

  </changeSet>


  <!-- =====================================================================================

    TM-282 : https://project.squashtest.org/browse/TM-282

  Summary
  +++++++

  The modelization in the database of CHART_QUERY and associated tables will now evolve into
  a generalized form, QUERY_MODEL (and associated tables).

  The previous model was incomplete, because in the context of charts we could make some
  assumptions that would make up for its shortcomings. For instance, the ordering was
  always set to Ascending, and always applied to Axis columns only.

  In the new modelization we now need those assumptions aren't always true and the missing
  concepts must be added. Instead of Axis, Measure and Filter we now have four possible
  roles for a Column Prototype : Projection, Aggregation, Filtering and Ordering. Note that
  the new semantic is much closer to SQL concepts, whereas the former one was closer
  to the business concepts (ie, the charts).


  Migration
  +++++++++

  The tables CHART_QUERY, CHART_AXIS_COLUMN, CHART_FILTER and CHART_MEASURE_COLUMN are special
  in the sense that they contain both referential data (you can generate a new schema from
  an earlier version and see they aren't initially empty), and user data (more entries goes
  into them as users create more charts).

  The referential data in those tables are the components of subqueries which calculate the
  value of certain CHART_COLUMN_PROTOTYPEs (ie of type 'CALCULATED'). They work exactly like
  user-defined queries and are treated just the same. Those elements that constitute the
  calculated subqueries are the sole property of squash-tm
  and will be re-modelized in the new format, ie they will be the initial entries for
  QUERY_MODEL, QUERY_PROJECTION_COLUMN etc. They will be removed from CHART_AXIS_COLUMN and alike
  accordingly, leaving only user data in them.

  Note that the former modelization will be partially maintained : CHART_AXIS_COLUMN will
  still exist despite being redundant regarding the new table QUERY_PROJECTION_COLUMN, which is
  almost identical in term of structure and function. Maintaining those redundant tables is
  interesting because :
    a/ we break much less code that way, especially in the UI and
    b/ charts are specialized queries for a dedicated business, and it makes sense to keep it
    that way instead of converting everything to a one-size-fit-all format (note : there is
    no eurosceptic subtext in that statement).

  However, when a chart query must be executed at runtime, the execution service should first
  be converted to the new QUERY_MODEL format (specifying ordering etc), because that's what
  the engine will now accept. This will be handled by code at runtime.


  Migration implementation
  ++++++++++++++++++++++++

  1 - tables CHART_QUERY and CHART_COLUMN_PROTOTYPE are renamed to QUERY_MODEL and QUERY_COLUMN_PROTOTYPE.
  Their primary keys are renamed as well for good measure. Inbound foreign keys are severed temporarily
  in order to perform those changes without inappropriate warnings.

  2 - tables QUERY_PROJECTION_COLUMN, QUERY_AGGREGATION_COLUMN, QUERY_FILTER_COLUMN and QUERY_ORDERING_COLUMN
  are created.

  3 - those tables are populated as follow :

  * referential entries of CHART_AXIS_COLUMN are transfered to QUERY_AGGREGATION_COLUMN and QUERY_ORDERING_COLUMN.

  * referential entries of CHART_FILTER is transferred as-is to QUERY_FILTER_COLUMN, so is the companion table
  CHART_FILTER_VALUES to QUERY_FILTER_VALUES.

  * referential entries of CHART_MEASURE_COLUMN is transferred to QUERY_PROJECTION_COLUMN and QUERY_ORDERING_COLUMN.
  If the referenced query already has one or several entries in QUERY_PROJECTION_COLUMN (ie axes we just migrated
  in the first step), the rank will be adjusted accordingly.

  4 - user-defined entries in tables CHART_AXIS_COLUMN, CHART_MEASURE_COLUMN and CHART_FILTER won't point anymore to a query,
  but directly to the CHART_DEFINITION.

  5 - referential data in the aforementioned tables are then removed.

  6 - the foreign keys that were disabled in step 1 are then restored.


  ====================================================================================== -->

  <changeSet id="tm-1.20.0-TM-282-00" author="bsiri">
    <comment>Preparatory step : dropping foreign keys pointing to CHART_QUERY and CHART_COLUMN_PROTOTYPE.</comment>


    <!-- foreign keys pointing to : CHART_QUERY -->

    <dropForeignKeyConstraint baseTableName="CHART_DEFINITION" constraintName="fk_chart_query"/>
    <dropForeignKeyConstraint baseTableName="CHART_COLUMN_PROTOTYPE" constraintName="fk_column_query"/>
    <dropForeignKeyConstraint baseTableName="CHART_AXIS_COLUMN" constraintName="fk_chart_axis_chart_query"/>
    <dropForeignKeyConstraint baseTableName="CHART_FILTER" constraintName="fk_chart_FILTER_chart_query"/>
    <dropForeignKeyConstraint baseTableName="CHART_MEASURE_COLUMN" constraintName="fk_chart_measure_chart_query"/>

    <!-- foreign keys pointing to : CHART_COLUMN_PROTOTYPE -->

    <dropForeignKeyConstraint baseTableName="CHART_COLUMN_ROLE" constraintName="fk_column_role_chart_column"/>
    <dropForeignKeyConstraint baseTableName="CHART_AXIS_COLUMN" constraintName="fk_axis_column_chart_column"/>
    <dropForeignKeyConstraint baseTableName="CHART_FILTER" constraintName="fk_chart_filter_chart_column"/>
    <dropForeignKeyConstraint baseTableName="CHART_MEASURE_COLUMN" constraintName="fk_chart_measure_chart_column"/>


  </changeSet>

  <changeSet id="tm-1.20.0-TM-282-01b-h2" author="bsiri" dbms="h2, postgresql">
    <comment>Rename CHART_QUERY and CHART_COLUMN_PROTOTYPE and their primary keys</comment>

    <dropPrimaryKey tableName="CHART_QUERY"/>
    <dropPrimaryKey tableName="CHART_COLUMN_PROTOTYPE"/>

    <renameTable oldTableName="CHART_QUERY" newTableName="QUERY_MODEL"/>
    <renameTable oldTableName="CHART_COLUMN_PROTOTYPE" newTableName="QUERY_COLUMN_PROTOTYPE"/>

    <renameColumn tableName="QUERY_MODEL" oldColumnName="CHART_QUERY_ID" newColumnName="QUERY_MODEL_ID" columnDataType="BIGINT"/>
    <renameColumn tableName="QUERY_COLUMN_PROTOTYPE" oldColumnName="CHART_COLUMN_ID" newColumnName="QUERY_COLUMN_ID" columnDataType="BIGINT" />

    <addPrimaryKey tableName="QUERY_MODEL" columnNames="QUERY_MODEL_ID" constraintName="pk_query_model"/>
    <addPrimaryKey tableName="QUERY_COLUMN_PROTOTYPE" columnNames="QUERY_COLUMN_ID" constraintName="pk_query_column_prototype"/>

  </changeSet>


  <changeSet id="tm-1.20.0-TM-282-01b-mysql" author="bsiri" dbms="mysql">

    <comment>Rename CHART_QUERY and CHART_COLUMN_PROTOTYPE and their primary keys</comment>

    <renameTable oldTableName="CHART_QUERY" newTableName="QUERY_MODEL"/>
    <renameTable oldTableName="CHART_COLUMN_PROTOTYPE" newTableName="QUERY_COLUMN_PROTOTYPE" />

    <renameColumn tableName="QUERY_MODEL" oldColumnName="CHART_QUERY_ID" newColumnName="QUERY_MODEL_ID" columnDataType="BIGINT"/>
    <renameColumn tableName="QUERY_COLUMN_PROTOTYPE" oldColumnName="CHART_COLUMN_ID" newColumnName="QUERY_COLUMN_ID" columnDataType="BIGINT" />

    <addAutoIncrement tableName="QUERY_MODEL" columnName="QUERY_MODEL_ID" columnDataType="BIGINT"/>
    <addAutoIncrement tableName="QUERY_COLUMN_PROTOTYPE" columnName="QUERY_COLUMN_ID" columnDataType="BIGINT"/>

  </changeSet>



  <changeSet id="tm-1.20.0-TM-282-02" author="bsiri">
    <comment>Create the new tables that hosts the query components.</comment>


    <comment>
      This table define which columns are part of tuple returned by a query.
    </comment>
    <createTable tableName="QUERY_PROJECTION_COLUMN" >

      <column name="QUERY_COLUMN_ID" type="BIGINT" remarks="foreign key to the QUERY_COLUMN_PROTOTYPE this projection applies to">
        <constraints nullable="false" foreignKeyName="fk_query_projection_query_column"
                     references="QUERY_COLUMN_PROTOTYPE(QUERY_COLUMN_ID)" />
      </column>

      <column name="QUERY_MODEL_ID" type="BIGINT" remarks="foreign key to a QUERY_MODEL">
        <constraints nullable="false"
                     foreignKeyName="fk_query_projection_query_model" references="QUERY_MODEL(QUERY_MODEL_ID)" />
      </column>

      <column name="LABEL" type="java.sql.Types.VARCHAR(30)"
              remarks="A label for this projected column. Will override the default label of the column prototype if non null."/>

      <column name="PROJECTION_OPERATION" type="java.sql.Types.VARCHAR(20)" remarks="the operation applied to the column, if any."/>

      <column name="PROJECTION_RANK" type="java.sql.Types.INTEGER"
              remarks="the order in which this projected column in the returned tuple."/>

      <column name="CUF_ID" type="BIGINT" remarks="the custom field id for this projection column, if the referenced column is a custom field."/>

    </createTable>



    <comment>
      This table indicates which projected columns are aggregated on for a given query.
    </comment>
    <createTable tableName="QUERY_AGGREGATION_COLUMN" >

      <column name="QUERY_MODEL_ID" type="BIGINT"
              remarks="foreign key to a QUERY_MODEL. ">
        <constraints nullable="false"
                     foreignKeyName="fk_query_aggr_query_model" references="QUERY_MODEL(QUERY_MODEL_ID)" />
      </column>

      <column name="QUERY_COLUMN_ID" type="BIGINT" remarks="foreign key to the QUERY_COLUMN_PROTOTYPE which must be aggregated on">
        <constraints nullable="false" foreignKeyName="fk_query_aggr_query_column"
                     references="QUERY_COLUMN_PROTOTYPE(QUERY_COLUMN_ID)" />
      </column>

      <column name="LABEL" type="java.sql.Types.VARCHAR(30)"
              remarks="A label for this projected column. Will override the default label of the column prototype if non null."/>

      <column name="AGGREGATION_OPERATION" type="java.sql.Types.VARCHAR(20)" remarks="the operation applied to the column, if any."/>

      <column name="AGGREGATION_RANK" type="java.sql.Types.INTEGER"
              remarks="the order in which this projected column in the returned tuple."/>

      <column name="CUF_ID" type="BIGINT" remarks="the custom field id for this projection column, if the referenced column is a custom field."/>

    </createTable>


    <comment>
      This table defines the columns on which one want to filter the data.
    </comment>

    <createTable tableName="QUERY_FILTER_COLUMN">
      <column name="QUERY_FILTER_ID" type="BIGINT" autoIncrement="true" remarks="autogenerated ID">
        <constraints primaryKey="true" nullable="false" />
      </column>

      <column name="QUERY_COLUMN_ID" type="BIGINT" remarks="foreign key to a QUERY_COLUMN_PROTOTYPE">
        <constraints nullable="false" foreignKeyName="fk_query_filter_query_column"
                     references="QUERY_COLUMN_PROTOTYPE(QUERY_COLUMN_ID)" />
      </column>

      <column name="QUERY_MODEL_ID" type="BIGINT" remarks="foreign key to a QUERY_MODEL">
        <constraints nullable="false"
                     foreignKeyName="fk_query_filter_query_model" references="QUERY_MODEL(QUERY_MODEL_ID)" />
      </column>

      <column name="FILTER_OPERATION" type="java.sql.Types.VARCHAR(20)" remarks="a comparison operator"/>

      <column name="CUF_ID" type="BIGINT" remarks="the custom field id for this filter column, if the referenced column is a custom field."/>

    </createTable>

    <createIndex tableName="QUERY_FILTER_COLUMN" indexName="idx_query_filter">
      <column name="QUERY_FILTER_ID" />
    </createIndex>




    <comment>
      This table holds the values used by a QUERY_FILTER_COLUMN.
    </comment>
    <createTable tableName="QUERY_FILTER_VALUES">

      <column name="QUERY_FILTER_ID" type="BIGINT" remarks="foreign key to QUERY_FILTER_COLUMN" >
        <constraints nullable="false"
                     foreignKeyName="fk_query_filter_value_query_filter" references="QUERY_FILTER_COLUMN(QUERY_FILTER_ID)" />
      </column>

      <column name="FILTER_VALUE" type="java.sql.Types.VARCHAR(255)" remarks="a value for this filter"/>

    </createTable>



    <comment>
      This table indicates how the projected columns are ordered.
    </comment>

    <createTable tableName="QUERY_ORDERING_COLUMN" >

      <column name="QUERY_MODEL_ID" type="BIGINT"
              remarks="foreign key to a QUERY_MODEL. Note that this is a denormalization : that value could be retrieved via the referenced projection column">
        <constraints nullable="false"
                     foreignKeyName="fk_query_order_query_model" references="QUERY_MODEL(QUERY_MODEL_ID)" />
      </column>

      <column name="QUERY_COLUMN_ID" type="BIGINT" remarks="foreign key to the QUERY_COLUMN_PROTOTYPE which must be ordered">
        <constraints nullable="false" foreignKeyName="fk_query_order_query_column"
                     references="QUERY_COLUMN_PROTOTYPE(QUERY_COLUMN_ID)" />
      </column>

      <column name="ORDER_OPERATION" type="java.sql.Types.VARCHAR(20)" remarks="the operation applied to the column, if any. It must mirror the operation applied to the column they reference in the projection/aggregation clause."/>

      <column name="ORDER_RANK" type="java.sql.Types.INTEGER"
              remarks="the order in which this ordering instruction must be treated."/>

      <column name="ORDER_DIR" type="java.sql.Types.CHAR(3)" defaultValue="ASC" remarks="either ASC or DESC"/>

      <column name="CUF_ID" type="BIGINT" remarks="the custom field id for this filter column, if the referenced column is a custom field."/>

    </createTable>

  </changeSet>


  <!--

    POPULATION OF THE NEW COLUMN TABLES

    The content of the new Projection, Aggregation, Filter and Ordering comes from the initial
    CHART_FILTER, CHART_FILTER_VALUES, CHART_AXIS_COLUMN and CHART_MEASURE_COLUMN.

    The process is the following :

    * CHART_AXIS_COLUMN are migrated first. Those columns are inserted as Aggregation and Ordering (asc only). Their rank are preserved.
    * CHART_MEASURE_COLUMN are migrated then. Those columns are inserted as Projections and Ordering. Their rank are adjusted, so that they come after the (former data from the) axes.
    * CHART_FILTER are migrated as-is, along with their values.

    Note that, however, the only entries that must be migrated are those that are part of subqueries (ie the strategy is <> 'MAIN').
    The other entries are user-defined data that should not be migrated.

  -->


  <changeSet id="tm-1.20.0-TM-282-03" author="bsiri">
    <comment>Now the fun part : migrate the former content into the new content</comment>

    <sql>

      -- --------------------
      -- migration of axis --
      -- --------------------

      insert into QUERY_AGGREGATION_COLUMN (query_model_id, label, aggregation_operation, aggregation_rank, cuf_id, query_column_id)
      select cac.query_id, cac.label, cac.axis_operation, cac.axis_rank, cac.cuf_id, cac.chart_column_id
      from CHART_AXIS_COLUMN cac
      inner join QUERY_MODEL qm on cac.query_id = qm.query_model_id
      where qm.strategy != 'MAIN';

      insert into QUERY_ORDERING_COLUMN (query_model_id, query_column_id, order_rank, order_dir, cuf_id, order_operation)
      select qac.query_model_id, qac.query_column_id, qac.aggregation_rank, 'ASC', qac.cuf_id, qac.aggregation_operation
      from QUERY_AGGREGATION_COLUMN qac;



      -- ------------------------
      -- migration of measures --
      -- ------------------------

      insert into QUERY_PROJECTION_COLUMN (query_column_id, query_model_id, label, projection_operation, cuf_id, projection_rank)
      select cmc.chart_column_id, cmc.query_id, cmc.label, cmc.measure_operation, cmc.cuf_id, cmc.measure_rank
      from CHART_MEASURE_COLUMN cmc
      inner join QUERY_MODEL qm on cmc.query_id = qm.query_model_id
      where qm.strategy != 'MAIN';

      insert into QUERY_ORDERING_COLUMN(query_model_id, query_column_id, order_dir, cuf_id, order_operation, order_rank)
      select cmc.query_id, cmc.chart_column_id, 'ASC', cmc.cuf_id, cmc.measure_operation, cmc.measure_rank + (
        select count(*) from CHART_AXIS_COLUMN cac where cac.query_id = cmc.query_id
      ) as adjust_rank
      from CHART_MEASURE_COLUMN cmc
      inner join QUERY_MODEL qm on cmc.query_id = qm.query_model_id
      where qm.strategy != 'MAIN';



      -- -----------------------
      -- migration of filters --
      -- -----------------------

      insert into QUERY_FILTER_COLUMN (query_column_id, query_model_id, filter_operation, cuf_id)
      select cfc.chart_column_id, cfc.query_id, cfc.filter_operation, cfc.cuf_id
      from CHART_FILTER cfc
      inner join QUERY_MODEL qm on cfc.query_id = qm.query_model_id
      where qm.strategy != 'MAIN';


      insert into QUERY_FILTER_VALUES (filter_value, query_filter_id)
      select cfv.filter_value, qfc.query_filter_id
      from CHART_FILTER_VALUES cfv
      inner join CHART_FILTER cfc on cfv.filter_id = cfc.filter_id
      inner join QUERY_MODEL qm on cfc.query_id = qm.query_model_id
      inner join QUERY_FILTER_COLUMN qfc on (
        cfc.chart_column_id = qfc.query_column_id and
        cfc.query_id = qfc.query_model_id and
        cfc.filter_operation = qfc.filter_operation
      )
      where qm.strategy != 'MAIN';


    </sql>
  </changeSet>


  <!--
    MORE REWIRING

    Tables CHART_FILTER, CHART_AXIS_COLUMN and CHART_MEASURE_COLUMN now point directly to the CHART_DEFINITION.
  -->


  <changeSet id="tm-1.20.0-TM-282-04a" author="bsiri">
    <comment>Creating the new foreign keys from CHART_X_COLUMNS tables, to CHART_DEFINITION. Initially nullable.</comment>

    <addColumn tableName="CHART_AXIS_COLUMN">
      <column name="CHART_DEFINITION_ID" type="BIGINT" remarks="foreign key to the chart_definition">
        <constraints nullable="true" foreignKeyName="fk_chart_axis_chart_def" references="CHART_DEFINITION(CHART_ID)"/>
      </column>
    </addColumn>

    <addColumn tableName="CHART_FILTER">
      <column name="CHART_DEFINITION_ID" type="BIGINT" remarks="foreign key to the chart_definition" >
        <constraints nullable="true" foreignKeyName="fk_chart_filter_chart_def" references="CHART_DEFINITION(CHART_ID)" />
      </column>
    </addColumn>

    <addColumn tableName="CHART_MEASURE_COLUMN">
      <column name="CHART_DEFINITION_ID" type="BIGINT" remarks="foreign key to the chart_definition">
        <constraints nullable="true" foreignKeyName="fk_chart_meas_chart_def" references="CHART_DEFINITION(CHART_ID)"/>
      </column>
    </addColumn>

  </changeSet>

  <changeSet id="tm-1.20.0-TM-282-04b" author="bsiri" dbms="h2,mysql">
    <comment>Populating the new foreign keys from the tables CHART_X_COLUMN  to CHART_DEFINITION</comment>

    <sql>
      update CHART_AXIS_COLUMN cac
      set cac.chart_definition_id = (
      select cd.chart_id
      from QUERY_MODEL qm
      inner join CHART_DEFINITION cd on qm.query_model_id = cd.query_id
      where qm.strategy = 'MAIN'
      and cac.query_id = qm.query_model_id
      );

      update CHART_FILTER cf
      set cf.chart_definition_id = (
      select cd.chart_id
      from QUERY_MODEL qm
      inner join CHART_DEFINITION cd on qm.query_model_id = cd.query_id
      where qm.strategy = 'MAIN'
      and cf.query_id = qm.query_model_id
      );

      update CHART_MEASURE_COLUMN cmc
      set cmc.chart_definition_id = (
      select cd.chart_id
      from QUERY_MODEL qm
      inner join CHART_DEFINITION cd on qm.query_model_id = cd.query_id
      where qm.strategy = 'MAIN'
      and cmc.query_id = qm.query_model_id
      );
    </sql>


  </changeSet>


  <changeSet id="tm-1.20.0-TM-282-04b-postgresql" author="bsiri" dbms="postgresql">
    <comment>Populating the new foreign keys from the tables CHART_X_COLUMN  to CHART_DEFINITION</comment>

    <sql>
      update CHART_AXIS_COLUMN
      set chart_definition_id = cd.chart_id
      from QUERY_MODEL qm
      inner join CHART_DEFINITION cd on qm.query_model_id = cd.query_id
      where qm.strategy = 'MAIN'
      and CHART_AXIS_COLUMN.query_id = qm.query_model_id;

      update CHART_FILTER
      set chart_definition_id = cd.chart_id
      from QUERY_MODEL qm
      inner join CHART_DEFINITION cd on qm.query_model_id = cd.query_id
      where qm.strategy = 'MAIN'
      and CHART_FILTER.query_id = qm.query_model_id;

      update CHART_MEASURE_COLUMN
      set chart_definition_id = cd.chart_id
      from QUERY_MODEL qm
      inner join CHART_DEFINITION cd on qm.query_model_id = cd.query_id
      where qm.strategy = 'MAIN'
      and CHART_MEASURE_COLUMN.query_id = qm.query_model_id;
    </sql>


  </changeSet>





  <changeSet id="tm-1.20.0-TM-282-04c" author="bsiri">
    <comment>Deleting the former referential data (that now exist in the new QUERY_X tables)</comment>

    <sql>

      delete from CHART_FILTER_VALUES
      where filter_id in (
      select filter_id from CHART_FILTER where chart_definition_id is null
      );

      delete from CHART_FILTER where chart_definition_id is null;

      delete from CHART_AXIS_COLUMN where chart_definition_id is null;

      delete from CHART_MEASURE_COLUMN where chart_definition_id is null;


    </sql>

    <comment>also delete the former QUERY_MODELs that previously had user data,
      because now the CHART_X_COLUMNS now solely rely on their CHART_DEFINITION
    </comment>

    <sql>
      delete from QUERY_MODEL where strategy = 'MAIN';
    </sql>

  </changeSet>


  <changeSet id="tm-1.20.0-TM-282-04d" author="bsiri">
    <comment>Now dropping the now useless columns that pointed to QUERY_MODEL </comment>

    <dropColumn tableName="CHART_AXIS_COLUMN" columnName="QUERY_ID"/>
    <dropColumn tableName="CHART_FILTER" columnName="QUERY_ID"/>
    <dropColumn tableName="CHART_MEASURE_COLUMN" columnName="QUERY_ID"/>

    <dropColumn tableName="CHART_DEFINITION" columnName="QUERY_ID"/>

  </changeSet>


  <!--
    FINALIZATION
  -->

  <changeSet id="tm-1.20.0-TM-282-05" author="bsiri">
    <comment>Rewiring the remaining foreign keys.</comment>


    <!-- foreign keys pointing to : CHART_QUERY -->
    <addForeignKeyConstraint constraintName="fk_query_col_query_model"
                             baseTableName="QUERY_COLUMN_PROTOTYPE" baseColumnNames="SUBQUERY_ID"
                             referencedTableName="QUERY_MODEL" referencedColumnNames="QUERY_MODEL_ID"/>


    <!-- foreign keys pointing to : CHART_COLUMN_PROTOTYPE -->

    <addForeignKeyConstraint constraintName="fk_column_role_chart_column"
                             baseTableName="CHART_COLUMN_ROLE" baseColumnNames="CHART_COLUMN_ID"
                             referencedTableName="QUERY_COLUMN_PROTOTYPE" referencedColumnNames="QUERY_COLUMN_ID"/>
    <addForeignKeyConstraint constraintName="fk_axis_column_chart_column"
                             baseTableName="CHART_AXIS_COLUMN" baseColumnNames="CHART_COLUMN_ID"
                             referencedTableName="QUERY_COLUMN_PROTOTYPE" referencedColumnNames="QUERY_COLUMN_ID"/>
    <addForeignKeyConstraint constraintName="fk_chart_filter_chart_column"
                             baseTableName="CHART_FILTER" baseColumnNames="CHART_COLUMN_ID"
                             referencedTableName="QUERY_COLUMN_PROTOTYPE" referencedColumnNames="QUERY_COLUMN_ID"/>
    <addForeignKeyConstraint constraintName="fk_chart_measure_chart_column"
                             baseTableName="CHART_MEASURE_COLUMN" baseColumnNames="CHART_COLUMN_ID"
                             referencedTableName="QUERY_COLUMN_PROTOTYPE" referencedColumnNames="QUERY_COLUMN_ID"/>


  </changeSet>



  <changeSet id="tm-1.20.0-TM-282-05b" author="bsiri" dbms="postgresql">

    <comment>For postgresql, we need to explicitly create the index on foreign key columns and ensure sequence order.</comment>

    <createIndex tableName="QUERY_PROJECTION_COLUMN" indexName="idx_fk_query_projection_query_column">
      <column name="QUERY_COLUMN_ID" type="BIGINT"/>
    </createIndex>
    <createIndex tableName="QUERY_PROJECTION_COLUMN" indexName="idx_fk_query_projection_query_model">
      <column name="QUERY_MODEL_ID" type="BIGINT"/>
    </createIndex>


    <createIndex tableName="QUERY_AGGREGATION_COLUMN" indexName="idx_fk_query_aggr_query_column">
      <column name="QUERY_COLUMN_ID" type="BIGINT"/>
    </createIndex>
    <createIndex tableName="QUERY_AGGREGATION_COLUMN" indexName="idx_fk_query_aggr_query_model">
      <column name="QUERY_MODEL_ID" type="BIGINT"/>
    </createIndex>


    <createIndex tableName="QUERY_FILTER_COLUMN" indexName="idx_fk_query_filter_query_column">
      <column name="QUERY_COLUMN_ID" type="BIGINT"/>
    </createIndex>
    <createIndex tableName="QUERY_FILTER_COLUMN" indexName="idx_fk_query_filter_query_model">
      <column name="QUERY_MODEL_ID" type="BIGINT"/>
    </createIndex>


    <createIndex tableName="QUERY_ORDERING_COLUMN" indexName="idx_fk_query_order_query_column">
      <column name="QUERY_COLUMN_ID" type="BIGINT"/>
    </createIndex>
    <createIndex tableName="QUERY_ORDERING_COLUMN" indexName="idx_fk_query_order_query_model">
      <column name="QUERY_MODEL_ID" type="BIGINT"/>
    </createIndex>


    <createIndex tableName="CHART_AXIS_COLUMN" indexName="idx_fk_chart_axis_chart_def">
      <column name="CHART_DEFINITION_ID" type="BIGINT"/>
    </createIndex>


    <createIndex tableName="CHART_FILTER" indexName="idx_fk_chart_filter_chart_def">
      <column name="CHART_DEFINITION_ID" type="BIGINT"/>
    </createIndex>


    <createIndex tableName="CHART_MEASURE_COLUMN" indexName="idx_fk_chart_meas_chart_def">
      <column name="CHART_DEFINITION_ID" type="BIGINT"/>
    </createIndex>

    <sql>
      DROP SEQUENCE chart_query_chart_query_id_seq CASCADE;
      CREATE SEQUENCE query_model_query_model_id_seq INCREMENT BY 1 OWNED BY QUERY_MODEL.QUERY_MODEL_ID;
      ALTER TABLE QUERY_MODEL ALTER COLUMN QUERY_MODEL_ID SET DEFAULT nextval('query_model_query_model_id_seq');
      SELECT setval('query_model_query_model_id_seq', (SELECT MAX(QUERY_MODEL_ID) from QUERY_MODEL));

      DROP SEQUENCE chart_column_prototype_chart_column_id_seq CASCADE;
      CREATE SEQUENCE query_column_prototype_query_column_id_seq INCREMENT BY 1 OWNED BY QUERY_COLUMN_PROTOTYPE.QUERY_COLUMN_ID;
      ALTER TABLE QUERY_COLUMN_PROTOTYPE ALTER COLUMN QUERY_COLUMN_ID SET DEFAULT nextval('query_column_prototype_query_column_id_seq');
      SELECT setval('query_column_prototype_query_column_id_seq', (SELECT MAX(QUERY_COLUMN_ID) from QUERY_COLUMN_PROTOTYPE));
    </sql>

  </changeSet>



  <changeSet id="tm-1.20.0-TM-282-06" author="bsiri">
    <comment>Inserting now the new columns and querymodels in the database</comment>
    <comment>For the subqueries we have to use (w)hacky SQL. This is because we need to select-insert from no table,
    which is supported with specific syntax by each table but aren't compatible together (we would need to
      'select from dual' in postgresql for example).
    </comment>

    <sql>

      -- ----------------------------------------------- --
      -- Inserting first the attribute columns. Some of  --
      -- them will be used in new query models, declared --
      -- just after them.                                --
      -- ----------------------------------------------- --

      INSERT INTO QUERY_COLUMN_PROTOTYPE (COLUMN_TYPE, ENTITY_TYPE, ENTITY_ROLE, LABEL, ATTRIBUTE_NAME, DATA_TYPE, BUSINESS) VALUES

      ('ATTRIBUTE', 'MILESTONE', 'TEST_CASE_MILESTONE', 'TEST_CASE_MILESTONE_LABEL', 'label', 'STRING', FALSE),
      ('ATTRIBUTE', 'MILESTONE', 'REQUIREMENT_VERSION_MILESTONE', 'REQUIREMENT_VERSION_MILESTONE_LABEL', 'label', 'STRING', FALSE),
      ('ATTRIBUTE', 'MILESTONE', 'CAMPAIGN_MILESTONE', 'CAMPAIGN_MILESTONE_LABEL', 'label', 'STRING', FALSE),

      ('ATTRIBUTE', 'PROJECT', 'TEST_CASE_PROJECT', 'TEST_CASE_PROJECT_NAME', 'name', 'STRING', FALSE),
      ('ATTRIBUTE', 'PROJECT', 'REQUIREMENT_PROJECT', 'REQUIREMENT_PROJECT_NAME', 'name', 'STRING', FALSE),
      ('ATTRIBUTE', 'PROJECT', 'CAMPAIGN_PROJECT', 'TEST_CASE_PROJECT_NAME', 'name', 'STRING', FALSE),


      ('ATTRIBUTE', 'ATTACHMENT_LIST', 'TEST_CASE_ATTLIST', 'TEST_CASE_ATTLIST_ID', 'id', 'NUMERIC', FALSE),
      ('ATTRIBUTE', 'ATTACHMENT_LIST', 'REQUIREMENT_ATTLIST', 'REQUIREMENT_ATTLIST_ID', 'id', 'NUMERIC', FALSE),
      ('ATTRIBUTE', 'ATTACHMENT_LIST', 'CAMPAIGN_ATTLIST', 'CAMPAIGN_ATTLIST_ID', 'id', 'NUMERIC', FALSE),

      ('ATTRIBUTE', 'ATTACHMENT', 'TEST_CASE_ATTACHMENT', 'TEST_CASE_ATTACHMENT_ID', 'id', 'NUMERIC', FALSE),
      ('ATTRIBUTE', 'ATTACHMENT', 'REQUIREMENT_ATTACHMENT', 'REQUIREMENT_ATTACHMENT_ID', 'id', 'NUMERIC', FALSE),
      ('ATTRIBUTE', 'ATTACHMENT', 'CAMPAIGN_ATTACHMENT', 'CAMPAIGN_ATTACHMENT_ID', 'id', 'NUMERIC', FALSE),

      ('ATTRIBUTE', 'DATASET', NULL, 'DATASET_ID', 'id', 'NUMERIC', FALSE),
      ('ATTRIBUTE', 'PARAMETER', NULL, 'PARAMETER_ID', 'id', 'NUMERIC', FALSE),

      ('ATTRIBUTE', 'MILESTONE', 'TEST_CASE_MILESTONE',   'TEST_CASE_MILESTONE_STATUS', 'status', 'LEVEL_ENUM', FALSE),
      ('ATTRIBUTE', 'MILESTONE', 'TEST_CASE_MILESTONE',   'TEST_CASE_MILESTONE_END_DATE', 'endDate', 'DATE', FALSE),
      ('ATTRIBUTE', 'MILESTONE', 'REQUIREMENT_MILESTONE', 'REQUIREMENT_MILESTONE_STATUS', 'status', 'LEVEL_ENUM', FALSE),
      ('ATTRIBUTE', 'MILESTONE', 'REQUIREMENT_MILESTONE', 'REQUIREMENT_MILESTONE_END_DATE', 'endDate', 'DATE', FALSE),
      ('ATTRIBUTE', 'MILESTONE', 'CAMPAIGN_MILESTONE',    'CAMPAIGN_MILESTONE_STATUS', 'status', 'LEVEL_ENUM', FALSE),
      ('ATTRIBUTE', 'MILESTONE', 'CAMPAIGN_MILESTONE',    'CAMPAIGN_MILESTONE_END_DATE', 'endDate', 'DATE', FALSE),

      ('ATTRIBUTE', 'AUTOMATION_REQUEST', NULL, 'AUTOMATION_REQUEST_ID', 'id', 'NUMERIC', FALSE),
      ('ATTRIBUTE', 'AUTOMATION_REQUEST', NULL, 'AUTOMATION_REQUEST_STATUS', 'requestStatus', 'NUMERIC', FALSE),

      ('ATTRIBUTE', 'REQUIREMENT_VERSION', NULL, 'REQUIREMENT_VERSION_NAME', 'name', 'STRING', FALSE),
      ('ATTRIBUTE', 'REQUIREMENT_VERSION', NULL, 'REQUIREMENT_VERSION_DESCRIPTION', 'description', 'STRING', FALSE),

      ('ATTRIBUTE', 'TEST_CASE', NULL, 'TEST_CASE_NAME', 'name', 'STRING', FALSE),
      ('ATTRIBUTE', 'TEST_CASE', NULL, 'TEST_CASE_DESCRIPTION', 'description', 'STRING', FALSE),
      ('ATTRIBUTE', 'TEST_CASE', NULL, 'TEST_CASE_KIND', 'kind', 'LEVEL_ENUM', FALSE),
      ('ATTRIBUTE', 'TEST_CASE', NULL, 'TEST_CASE_PREQUISITE', 'prerequisite', 'STRING', FALSE),
      ('ATTRIBUTE', 'TEST_CASE', NULL, 'TEST_CASE_AUTOMATABLE', 'automatable', 'LEVEL_ENUM', FALSE),

      ('ATTRIBUTE', 'CAMPAIGN', NULL, 'CAMPAIGN_NAME', 'name', 'STRING', FALSE),

      ('ATTRIBUTE', 'ITERATION', NULL, 'ITERATION_NAME', 'name', 'STRING', FALSE),

      ('ATTRIBUTE', 'TEST_SUITE', 'ITEM_SUITE', 'ITEM_SUITE_ID', 'id', 'NUMERIC', FALSE),

      ('ATTRIBUTE', 'EXECUTION', 'NULL', 'EXECUTION_EXECUTION_MODE', 'executionMode', 'LEVEL_ENUM', FALSE),
      ('ATTRIBUTE', 'EXECUTION', 'NULL', 'EXECUTION_LAST_EXECUTED_ON', 'lastExecutedOn', 'DATE', FALSE);



      -- ----------------------------------------------- --
      -- Inserting subqueries that implement the         --
      -- 'CALCULATED' columns defined right after them   --
      -- ----------------------------------------------- --


      -- requirement version attachment count subquery
      -- the inserts follow the order : query_model, aggregation, projection and finally the query_column_prototype

      INSERT INTO QUERY_MODEL (NAME, STRATEGY, JOIN_STYLE) values ('REQUIREMENT_VERSION_ATTCOUNT_SUBQUERY', 'SUBQUERY', 'LEFT_JOIN');

      INSERT INTO QUERY_AGGREGATION_COLUMN(QUERY_MODEL_ID, QUERY_COLUMN_ID, AGGREGATION_OPERATION, AGGREGATION_RANK)
        select
          (select max(QUERY_MODEL_ID) from QUERY_MODEL),
          (select QUERY_COLUMN_ID from QUERY_COLUMN_PROTOTYPE where label = 'REQUIREMENT_VERSION_ID'),
          'NONE', 0
        from QUERY_COLUMN_PROTOTYPE where query_column_id = 1;


      INSERT INTO QUERY_PROJECTION_COLUMN(QUERY_MODEL_ID, QUERY_COLUMN_ID, PROJECTION_OPERATION, PROJECTION_RANK)
        select
          (select max(QUERY_MODEL_ID) from QUERY_MODEL),
          (select QUERY_COLUMN_ID from QUERY_COLUMN_PROTOTYPE where label = 'REQUIREMENT_ATTACHMENT_ID'),
          'COUNT', 0
        from QUERY_COLUMN_PROTOTYPE where query_column_id = 1;

      INSERT INTO QUERY_COLUMN_PROTOTYPE (COLUMN_TYPE, ENTITY_TYPE, ENTITY_ROLE, LABEL, ATTRIBUTE_NAME, DATA_TYPE, BUSINESS, SUBQUERY_ID)
        select
          'CALCULATED', 'REQUIREMENT_VERSION', NULL, 'REQUIREMENT_VERSION_ATTCOUNT', 'count(attachment)', 'NUMERIC', FALSE,
          (select max(QUERY_MODEL_ID) from QUERY_MODEL)
        from QUERY_COLUMN_PROTOTYPE where query_column_id = 1;



      -- test case attachment count subquery
      -- the inserts follow the order : query_model, aggregation, projection and finally the query_column_prototype

      INSERT INTO QUERY_MODEL (NAME, STRATEGY, JOIN_STYLE) values ('TEST_CASE_ATTCOUNT_SUBQUERY', 'SUBQUERY', 'LEFT_JOIN');

      INSERT INTO QUERY_AGGREGATION_COLUMN(QUERY_MODEL_ID, QUERY_COLUMN_ID, AGGREGATION_OPERATION, AGGREGATION_RANK)
        select
          (select max(QUERY_MODEL_ID) from QUERY_MODEL),
          (select QUERY_COLUMN_ID from QUERY_COLUMN_PROTOTYPE where label = 'TEST_CASE_ID'),
          'NONE', 0
        from QUERY_COLUMN_PROTOTYPE where query_column_id = 1;


      INSERT INTO QUERY_PROJECTION_COLUMN(QUERY_MODEL_ID, QUERY_COLUMN_ID, PROJECTION_OPERATION, PROJECTION_RANK)
        select
          (select max(QUERY_MODEL_ID) from QUERY_MODEL),
          (select QUERY_COLUMN_ID from QUERY_COLUMN_PROTOTYPE where label = 'TEST_CASE_ATTACHMENT_ID'),
          'COUNT', 0
        from QUERY_COLUMN_PROTOTYPE where query_column_id = 1;

      INSERT INTO QUERY_COLUMN_PROTOTYPE (COLUMN_TYPE, ENTITY_TYPE, ENTITY_ROLE, LABEL, ATTRIBUTE_NAME, DATA_TYPE, BUSINESS, SUBQUERY_ID)
      select
      'CALCULATED', 'TEST_CASE', NULL, 'TEST_CASE_ATTCOUNT', 'count(attachment)', 'NUMERIC', FALSE,
      (select max(QUERY_MODEL_ID) from QUERY_MODEL)
      from QUERY_COLUMN_PROTOTYPE where query_column_id = 1;



      -- test case parameter count subquery
      -- the inserts follow the order : query_model, aggregation, projection and finally the query_column_prototype

      INSERT INTO QUERY_MODEL (NAME, STRATEGY, JOIN_STYLE) values ('TEST_CASE_PARAMCOUNT_SUBQUERY', 'SUBQUERY', 'LEFT_JOIN');

      INSERT INTO QUERY_AGGREGATION_COLUMN(QUERY_MODEL_ID, QUERY_COLUMN_ID, AGGREGATION_OPERATION, AGGREGATION_RANK)
      select
      (select max(QUERY_MODEL_ID) from QUERY_MODEL),
      (select QUERY_COLUMN_ID from QUERY_COLUMN_PROTOTYPE where label = 'TEST_CASE_ID'),
      'NONE', 0
      from QUERY_COLUMN_PROTOTYPE where query_column_id = 1;


      INSERT INTO QUERY_PROJECTION_COLUMN(QUERY_MODEL_ID, QUERY_COLUMN_ID, PROJECTION_OPERATION, PROJECTION_RANK)
      select
      (select max(QUERY_MODEL_ID) from QUERY_MODEL),
      (select QUERY_COLUMN_ID from QUERY_COLUMN_PROTOTYPE where label = 'PARAMETER_ID'),
      'COUNT', 0
      from QUERY_COLUMN_PROTOTYPE where query_column_id = 1;

      INSERT INTO QUERY_COLUMN_PROTOTYPE (COLUMN_TYPE, ENTITY_TYPE, ENTITY_ROLE, LABEL, ATTRIBUTE_NAME, DATA_TYPE, BUSINESS, SUBQUERY_ID)
      select
      'CALCULATED', 'TEST_CASE', NULL, 'TEST_CASE_PARAMCOUNT', 'count(parameter)', 'NUMERIC', FALSE,
      (select max(QUERY_MODEL_ID) from QUERY_MODEL)
      from QUERY_COLUMN_PROTOTYPE where query_column_id = 1;



      -- test case dataset count subquery
      -- the inserts follow the order : query_model, aggregation, projection and finally the query_column_prototype

      INSERT INTO QUERY_MODEL (NAME, STRATEGY, JOIN_STYLE) values ('TEST_CASE_DATASETCOUNT_SUBQUERY', 'SUBQUERY', 'LEFT_JOIN');

      INSERT INTO QUERY_AGGREGATION_COLUMN(QUERY_MODEL_ID, QUERY_COLUMN_ID, AGGREGATION_OPERATION, AGGREGATION_RANK)
      select
      (select max(QUERY_MODEL_ID) from QUERY_MODEL),
      (select QUERY_COLUMN_ID from QUERY_COLUMN_PROTOTYPE where label = 'TEST_CASE_ID'),
      'NONE', 0
      from QUERY_COLUMN_PROTOTYPE where query_column_id = 1;


      INSERT INTO QUERY_PROJECTION_COLUMN(QUERY_MODEL_ID, QUERY_COLUMN_ID, PROJECTION_OPERATION, PROJECTION_RANK)
      select
      (select max(QUERY_MODEL_ID) from QUERY_MODEL),
      (select QUERY_COLUMN_ID from QUERY_COLUMN_PROTOTYPE where label = 'DATASET_ID'),
      'COUNT', 0
      from QUERY_COLUMN_PROTOTYPE where query_column_id = 1;


      INSERT INTO QUERY_COLUMN_PROTOTYPE (COLUMN_TYPE, ENTITY_TYPE, ENTITY_ROLE, LABEL, ATTRIBUTE_NAME, DATA_TYPE, BUSINESS, SUBQUERY_ID)
      select
      'CALCULATED', 'TEST_CASE', NULL, 'TEST_CASE_DATASETCOUNT', 'count(dataset)', 'NUMERIC', FALSE,
      (select max(QUERY_MODEL_ID) from QUERY_MODEL)
      from QUERY_COLUMN_PROTOTYPE where query_column_id = 1;


      -- item suite count subquery
      -- the inserts follow the order : query_model, aggregation, projection and finally the query_column_prototype

      INSERT INTO QUERY_MODEL (NAME, STRATEGY, JOIN_STYLE) values ('ITEM_TEST_PLAN_SUITECOUNT_SUBQUERY', 'SUBQUERY', 'LEFT_JOIN');

      INSERT INTO QUERY_AGGREGATION_COLUMN(QUERY_MODEL_ID, QUERY_COLUMN_ID, AGGREGATION_OPERATION, AGGREGATION_RANK)
      select
      (select max(QUERY_MODEL_ID) from QUERY_MODEL),
      (select QUERY_COLUMN_ID from QUERY_COLUMN_PROTOTYPE where label = 'ITEM_TEST_PLAN_ID'),
      'NONE', 0
      from QUERY_COLUMN_PROTOTYPE where query_column_id = 1;


      INSERT INTO QUERY_PROJECTION_COLUMN(QUERY_MODEL_ID, QUERY_COLUMN_ID, PROJECTION_OPERATION, PROJECTION_RANK)
      select
      (select max(QUERY_MODEL_ID) from QUERY_MODEL),
      (select QUERY_COLUMN_ID from QUERY_COLUMN_PROTOTYPE where label = 'ITEM_SUITE_ID'),
      'COUNT', 0
      from QUERY_COLUMN_PROTOTYPE where query_column_id = 1;


      INSERT INTO QUERY_COLUMN_PROTOTYPE (COLUMN_TYPE, ENTITY_TYPE, ENTITY_ROLE, LABEL, ATTRIBUTE_NAME, DATA_TYPE, BUSINESS, SUBQUERY_ID)
      select
      'CALCULATED', 'ITEM_TEST_PLAN', NULL, 'ITEM_TEST_PLAN_SUITECOUNT', 'count(testSuites)', 'NUMERIC', FALSE,
      (select max(QUERY_MODEL_ID) from QUERY_MODEL)
      from QUERY_COLUMN_PROTOTYPE where query_column_id = 1;



      -- item dataset count subquery
      -- the inserts follow the order : query_model, aggregation, projection and finally the query_column_prototype

      INSERT INTO QUERY_MODEL (NAME, STRATEGY, JOIN_STYLE) values ('ITEM_TEST_PLAN_DSCOUNT_SUBQUERY', 'SUBQUERY', 'LEFT_JOIN');


      INSERT INTO QUERY_AGGREGATION_COLUMN(QUERY_MODEL_ID, QUERY_COLUMN_ID, AGGREGATION_OPERATION, AGGREGATION_RANK)
      select
      (select max(QUERY_MODEL_ID) from QUERY_MODEL),
      (select QUERY_COLUMN_ID from QUERY_COLUMN_PROTOTYPE where label = 'ITEM_TEST_PLAN_ID'),
      'NONE', 0
      from QUERY_COLUMN_PROTOTYPE where query_column_id = 1;


      INSERT INTO QUERY_PROJECTION_COLUMN(QUERY_MODEL_ID, QUERY_COLUMN_ID, PROJECTION_OPERATION, PROJECTION_RANK)
      select
      (select max(QUERY_MODEL_ID) from QUERY_MODEL),
      (select QUERY_COLUMN_ID from QUERY_COLUMN_PROTOTYPE where label = 'DATASET_ID'),
      'COUNT', 0
      from QUERY_COLUMN_PROTOTYPE where query_column_id = 1;


      INSERT INTO QUERY_COLUMN_PROTOTYPE (COLUMN_TYPE, ENTITY_TYPE, ENTITY_ROLE, LABEL, ATTRIBUTE_NAME, DATA_TYPE, BUSINESS, SUBQUERY_ID)
      select
      'CALCULATED', 'ITEM_TEST_PLAN', NULL, 'ITEM_TEST_PLAN_DSCOUNT', 'count(datasets)', 'NUMERIC', FALSE,
      (select max(QUERY_MODEL_ID) from QUERY_MODEL)
      from QUERY_COLUMN_PROTOTYPE where query_column_id = 1;


    </sql>

  </changeSet>

</databaseChangeLog>
