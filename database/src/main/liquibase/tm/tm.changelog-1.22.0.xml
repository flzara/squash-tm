<?xml version="1.0" encoding="UTF-8"?>
<!--

        This file is part of the Squashtest platform.
        Copyright (C) Henix, henix.fr

        See the NOTICE file distributed with this work for additional
        information regarding copyright ownership.

        This is free software: you can redistribute it and/or modify
        it under the terms of the GNU Lesser General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        this software is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU Lesser General Public License for more details.

        You should have received a copy of the GNU Lesser General Public License
        along with this software.  If not, see <http://www.gnu.org/licenses/>.

-->
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-2.0.xsd">

  <changeSet id="tm-1.22.0" author="jthebault">
    <comment>Update TM database version number</comment>
    <update tableName="CORE_CONFIG">
      <column name="VALUE" value="1.22.0"/>
      <where>STR_KEY = 'squashtest.tm.database.version'</where>
    </update>
  </changeSet>

  <!-- Story SQUASH-167 : adding iteration UUID for external reference -->
  <changeSet id="tm-1.22.0-squash-167-test-it-uuid-for-tf-side-trigger" author="edegenetais">
    <addColumn tableName="ITERATION">
      <column name="UUID" type="java.sql.Types.VARCHAR(36)" />
    </addColumn>
    <addUniqueConstraint tableName="ITERATION" columnNames="UUID" constraintName="uc_iteration_uuid" />
  </changeSet>

  <changeSet id="tm-1.22.0-squash-167-update-iteration-uuid-postgresql" author="edegenetais" dbms="postgresql">
    <comment>Created missing UUIDs on upgrade to add the not-null constraint.</comment>
    <sql>
      CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
      UPDATE ITERATION SET UUID = uuid_generate_v4() WHERE UUID is NULL;
      ALTER TABLE ITERATION ALTER COLUMN UUID SET NOT NULL;
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-squash-167-update-iteration-uuid-mysql" author="edegenetais" dbms="mysql">
    <comment>Created missing UUIDs on upgrade to add the not-null constraint.</comment>
    <sql>
      UPDATE ITERATION SET UUID = uuid() WHERE UUID is NULL;
      ALTER TABLE ITERATION MODIFY UUID VARCHAR(36) NOT NULL;
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-squash-167-update-iteration-uuid-h2" author="edegenetais" dbms="h2">
    <comment>Created missing UUIDs on upgrade to add the not-null constraint.</comment>
    <sql>
      UPDATE ITERATION SET UUID = random_uuid() WHERE UUID is NULL;
      ALTER TABLE ITERATION MODIFY UUID VARCHAR(36) NOT NULL;
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-174-action-word-table" author="jlor">
    <comment>Add action word table</comment>

    <createTable tableName="ACTION_WORD">

      <column name="ACTION_WORD_ID" type="BIGINT" autoIncrement="true">
        <constraints primaryKey="true" nullable="false"/>
      </column>

      <column name="DESCRIPTION" type="CLOB" />

      <column name="CREATED_BY" type="VARCHAR(50)">
        <constraints nullable="false" />
      </column>

      <column name="CREATED_ON" type="DATETIME">
        <constraints nullable="false" />
      </column>

      <column name="LAST_MODIFIED_BY" type="VARCHAR(50)" defaultValue="NULL" />

      <column name="LAST_MODIFIED_ON" type="DATETIME" defaultValue="NULL" />

      <column name="TOKEN" type="VARCHAR(766)">
        <constraints nullable="false" />
      </column>

      <column name="PROJECT_ID" type="BIGINT">
        <constraints references="PROJECT(PROJECT_ID)" nullable="false" foreignKeyName="fk_action_word_project" />
      </column>
    </createTable>


    <createIndex tableName="ACTION_WORD" indexName="idx_fk_action_word_project">
      <column name="PROJECT_ID" />
    </createIndex>

    <addUniqueConstraint tableName="ACTION_WORD" columnNames="TOKEN, PROJECT_ID"
                         constraintName="uc_aw_token_project_id"/>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-174-keyword-test-step-table" author="jlor" >
    <comment>Add keyword test step table</comment>

    <createTable tableName="KEYWORD_TEST_STEP">
      <column name="TEST_STEP_ID" type="BIGINT" remarks="Shared key with TEST_STEP table">
        <constraints primaryKey="true" nullable="false" references="TEST_STEP(TEST_STEP_ID)" primaryKeyName="pk_keyword_test_step"
                     foreignKeyName="fk_keyword_test_step_test_step"/>
      </column>

      <column name="ACTION_WORD_ID" type="BIGINT" remarks="The action word which this test step uses">
        <constraints nullable="false" foreignKeyName="fk_keyword_test_step_action_word_id" references="ACTION_WORD (ACTION_WORD_ID)"/>
      </column>

      <!-- SQUASH-175 - Add KEYWORD column in KEYWORD_TEST_STEP table -->
      <column name="KEYWORD" type="java.sql.Types.VARCHAR(20)" remarks="A keyword test step keyword">
        <constraints nullable="false" />
      </column>

      <!-- SQUASH-1476 - Add DATATABLE column in KEYWORD_TEST_STEP table -->
      <column name="DATATABLE" type="TEXT" remarks="A keyword test step datatable" />

      <!-- SQUASH-1498 - Add DOCSTRING column in KEYWORD_TEST_STEP table -->
      <column name="DOCSTRING" type="TEXT" remarks="A keyword test step docstring" />

      <!-- SQUASH-1503 - Add COMMENT column in KEYWORD_TEST_STEP table -->
      <column name="COMMENT" type="TEXT" remarks="A keyword test step comment" />
    </createTable>

    <createIndex tableName="KEYWORD_TEST_STEP" indexName="idx_fk_keyword_test_step_action_word">
      <column name="ACTION_WORD_ID" />
    </createIndex>

  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-174-update-query-filter" author="jlor">
    <comment>Changes in QueryBuilder related tables concerning TEST_CASE_CALLSTEPCOUNT prototype column: adding a new subclass of TestStep (KeywordTestStep) broke the QueryBuilder</comment>
    <sql>update QUERY_FILTER_VALUES set FILTER_VALUE='org.squashtest.tm.domain.testcase.CallTestStep' where QUERY_FILTER_ID=1;</sql>
    <sql>update QUERY_FILTER_COLUMN set QUERY_COLUMN_ID=134, FILTER_OPERATION='IS_CLASS' where QUERY_FILTER_ID=1;</sql>
  </changeSet>

  <changeSet id="tm-1.22.0-drop-temp_execution_extender_order_table-postgresql" author="jlor" dbms="postgresql">
    <comment>Drop TEMP_EXECUTION_EXTENDER_ORDER table for PostgreSQL</comment>
    <dropTable tableName="TEMP_EXECUTION_EXTENDER_ORDER" />
  </changeSet>

  <changeSet id="tm-1.22.0-drop-temp_execution_extender_order_table-h2" author="jlor" dbms="h2">
    <comment>Drop TEMP_EXECUTION_EXTENDER_ORDER table for h2</comment>
    <dropTable tableName="TEMP_EXECUTION_EXTENDER_ORDER" />
  </changeSet>

  <changeSet id="tm-1.22.0-TEST_CASE_HIERARCHY_MODIFICATION" author="jlor">
    <comment>Create KEYWORD_TEST_CASE table. Update SCRIPTED_TC_EXTENDER table/column</comment>

    <createTable tableName="KEYWORD_TEST_CASE">
      <column name="TCLN_ID" type="BIGINT">
        <constraints primaryKey="true" foreignKeyName="fk_keyword_tc_tc" references="TEST_CASE(TCLN_ID)"/>
      </column>
    </createTable>

    <dropColumn tableName="SCRIPTED_TC_EXTENDER" columnName="SCRIPTED_TC_EXTENDER_ID" />
    <renameTable oldTableName="SCRIPTED_TC_EXTENDER" newTableName="SCRIPTED_TEST_CASE" />
    <dropForeignKeyConstraint baseTableName="SCRIPTED_TEST_CASE" constraintName="fk_scripted_extender_test_case"/>
    <renameColumn tableName="SCRIPTED_TEST_CASE" oldColumnName="TEST_CASE_ID" newColumnName="TCLN_ID" columnDataType="BIGINT" />
    <addForeignKeyConstraint constraintName="fk_scripted_extender_test_case" baseTableName="SCRIPTED_TEST_CASE"
                             baseColumnNames="TCLN_ID" referencedTableName="TEST_CASE" referencedColumnNames="TCLN_ID" />
    <addPrimaryKey tableName="SCRIPTED_TEST_CASE" columnNames="TCLN_ID" />

  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-325-update-tc-kind-column-prototype" author="jlor">
    <comment>In QueryColumnPrototype table, at TestCaseKind line, change data_type column value from Level_enum to Entity</comment>
    <sql>update QUERY_COLUMN_PROTOTYPE set DATA_TYPE='ENTITY', COLUMN_TYPE='ENTITY' where QUERY_COLUMN_ID=184;</sql>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-325-drop-tc-kind-column" author="jlor">
    <dropColumn tableName="TEST_CASE" columnName="TC_KIND" />
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-325-drop-language-column-in-scripted-tc" author="jlor">
    <comment>LANGUAGE is no longer necessary for ScriptedTestCase, as it is always GHERKIN.</comment>
    <dropColumn tableName="SCRIPTED_TEST_CASE" columnName="LANGUAGE" />
  </changeSet>

  <!-- Story SQUASH-421 : adding test suite UUID for external reference -->
  <changeSet id="tm-1.22.0-squash-421-add-test-suite-uuid" author="aguilhem">
    <addColumn tableName="TEST_SUITE">
      <column name="UUID" type="java.sql.Types.VARCHAR(36)" />
    </addColumn>
    <addUniqueConstraint tableName="TEST_SUITE" columnNames="UUID" constraintName="uc_test_suite_uuid" />
  </changeSet>

  <changeSet id="tm-1.22.0-squash-421-update-test-suite-uuid-postgresql" author="aguilhem" dbms="postgresql">
    <comment>Created missing UUIDs on upgrade to add the not-null constraint.</comment>
    <sql>
      CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
      UPDATE TEST_SUITE SET UUID = uuid_generate_v4() WHERE UUID is NULL;
      ALTER TABLE TEST_SUITE ALTER COLUMN UUID SET NOT NULL;
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-squash-421-update-test-suite-uuid-mysql" author="aguilhem" dbms="mysql">
    <comment>Created missing UUIDs on upgrade to add the not-null constraint.</comment>
    <sql>
      UPDATE TEST_SUITE SET UUID = uuid() WHERE UUID is NULL;
      ALTER TABLE TEST_SUITE MODIFY UUID VARCHAR(36) NOT NULL;
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-squash-421-update-test-suite-uuid-h2" author="aguilhem" dbms="h2">
    <comment>Created missing UUIDs on upgrade to add the not-null constraint.</comment>
    <sql>
      UPDATE TEST_SUITE SET UUID = random_uuid() WHERE UUID is NULL;
      ALTER TABLE TEST_SUITE MODIFY UUID VARCHAR(36) NOT NULL;
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-325-EXECUTION_HIERARCHY_MODIFICATION" author="jlor">
    <comment>Create KEYWORD_EXECUTION table. Update SCRIPTED_EXECUTION_EXTENDER table/column.</comment>

    <renameTable oldTableName="SCRIPTED_EXECUTION_EXTENDER" newTableName="SCRIPTED_EXECUTION" />
    <dropColumn tableName="SCRIPTED_EXECUTION" columnName="SCRIPTED_EXECUTION_EXTENDER_ID" />
    <addPrimaryKey tableName="SCRIPTED_EXECUTION" columnNames="EXECUTION_ID" />
    <dropColumn tableName="SCRIPTED_EXECUTION" columnName="LANGUAGE" />

    <createTable tableName="KEYWORD_EXECUTION">
      <column name="EXECUTION_ID" type="BIGINT">
        <constraints primaryKey="true" foreignKeyName="fk_keyword_exec_exec" references="EXECUTION(EXECUTION_ID)" />
      </column>
    </createTable>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-350-PARAMETER_IN_ACTION_WORD" author="qtran">
    <comment>Create ACTION_WORD_FRAGMENT table</comment>
    <createTable tableName="ACTION_WORD_FRAGMENT" remarks="base table for Action word fragments">
      <column name="ACTION_WORD_FRAGMENT_ID" type="BIGINT" autoIncrement="true" remarks="primary key, auto-generated">
        <constraints primaryKey="true" nullable="false" primaryKeyName="PK_ACTION_WORD_FRAGMENT"/>
      </column>

      <column name="ACTION_WORD_ID" type="BIGINT" remarks="Foreign key to the action word">
        <constraints nullable="true" foreignKeyName="fk_action_word_fragment_action_word_id" references="ACTION_WORD(ACTION_WORD_ID)"/>
      </column>

      <column name="FRAGMENT_ORDER" type="int"
              remarks="the fragment order in action word fragment list">
        <constraints nullable="true" />
      </column>
    </createTable>

    <createIndex tableName="ACTION_WORD_FRAGMENT" indexName="idx_fk_action_word_fragment_action_word_id">
      <column name="ACTION_WORD_ID" />
    </createIndex>

    <addUniqueConstraint tableName="ACTION_WORD_FRAGMENT" columnNames="ACTION_WORD_ID, FRAGMENT_ORDER"
                         constraintName="uc_action_word_fragment_order"/>

    <comment>Create new table for Action word text elements</comment>
    <createTable tableName="ACTION_WORD_TEXT">
      <column name="ACTION_WORD_FRAGMENT_ID" type="BIGINT" remarks="Shared key with ACTION_WORD_FRAGMENT table">
        <constraints primaryKey="true" nullable="false" references="ACTION_WORD_FRAGMENT(ACTION_WORD_FRAGMENT_ID)"
                     primaryKeyName="PK_ACTION_WORD_TEXT" foreignKeyName="fk_action_word_text_action_word_fragment"/>
      </column>
      <column name="TEXT" type="VARCHAR(255)" remarks="the content of the action word text">
        <constraints nullable="false"/>
      </column>
    </createTable>

    <createIndex tableName="ACTION_WORD_TEXT" indexName="idx_fk_action_word_text_action_word_fragment">
      <column name="ACTION_WORD_FRAGMENT_ID" />
    </createIndex>

    <comment>Create new table for Action word parameter elements</comment>
    <createTable tableName="ACTION_WORD_PARAMETER">
      <column name="ACTION_WORD_FRAGMENT_ID" type="BIGINT" remarks="Shared key with ACTION_WORD_FRAGMENT table">
        <constraints primaryKey="true" nullable="false" references="ACTION_WORD_FRAGMENT(ACTION_WORD_FRAGMENT_ID)"
                     primaryKeyName="PK_ACTION_WORD_PARAMETER" foreignKeyName="fk_action_word_parameter_action_word_fragment"/>
      </column>
      <column name="NAME" type="VARCHAR(255)" remarks="the name of the action word parameter">
        <constraints nullable="false"/>
      </column>
      <column name="DEFAULT_VALUE" type="VARCHAR(255)" remarks="the default value of the action word parameter">
        <constraints nullable="false"/>
      </column>
    </createTable>

    <createIndex tableName="ACTION_WORD_PARAMETER" indexName="idx_fk_action_word_parameter_action_word_fragment">
      <column name="ACTION_WORD_FRAGMENT_ID" />
    </createIndex>

    <comment>Create new table for Action word parameter value</comment>
    <createTable tableName="ACTION_WORD_PARAMETER_VALUE">
      <column name="ACTION_WORD_PARAMETER_VALUE_ID" type="BIGINT" autoIncrement="true"  remarks="primary key, auto-generated">
        <constraints primaryKey="true" nullable="false" primaryKeyName="PK_ACTION_WORD_PARAMETER_VALUE"/>
      </column>
      <column name="VALUE" type="VARCHAR(255)" remarks="the value of the action word parameter value">
        <constraints nullable="false"/>
      </column>
      <column name="ACTION_WORD_FRAGMENT_ID" type="BIGINT" remarks="the action word parameter by which this value replaces">
        <constraints nullable="false" foreignKeyName="fk_action_word_parameter_value_action_word_fragment_id"
                      references="ACTION_WORD_PARAMETER(ACTION_WORD_FRAGMENT_ID)"/>
      </column>
      <column name="KEYWORD_TEST_STEP_ID" type="BIGINT" remarks="the keyword test step in which this value is used">
        <constraints nullable="false" foreignKeyName="fk_action_word_parameter_value_keyword_test_step_id"
                     references="KEYWORD_TEST_STEP(TEST_STEP_ID)"/>
      </column>
    </createTable>


    <createIndex tableName="ACTION_WORD_PARAMETER_VALUE" indexName="idx_fk_action_word_parameter_value_action_word_fragment_id">
      <column name="ACTION_WORD_FRAGMENT_ID" />
    </createIndex>
    <createIndex tableName="ACTION_WORD_PARAMETER_VALUE" indexName="idx_fk_action_word_parameter_value_keyword_test_step_id">
      <column name="KEYWORD_TEST_STEP_ID" />
    </createIndex>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-302-action-word-workspace" author="jlor">
    <comment>Create action word library table</comment>

    <createTable tableName="ACTION_WORD_LIBRARY">
      <column name="AWL_ID" type="BIGINT" autoIncrement="true" remarks="The auto-generated id">
        <constraints primaryKey="true" nullable="false" primaryKeyName="PK_ACTION_WORD_LIBRARY" />
      </column>

      <column name="ATTACHMENT_LIST_ID" type="BIGINT" remarks="Foreign key to ATTACHMENT_LIST">
        <constraints references="ATTACHMENT_LIST(ATTACHMENT_LIST_ID)" foreignKeyName="fk_awLib_attachment_list" />
      </column>
    </createTable>

    <createIndex tableName="ACTION_WORD_LIBRARY" indexName="idx_action_word_library">
    <column name="AWL_ID" />
  </createIndex>

    <createIndex tableName="ACTION_WORD_LIBRARY" indexName="idx_fk_awl_attachment_list">
      <column name="ATTACHMENT_LIST_ID" />
    </createIndex>

    <comment>Insert corresponding entries in ACL tables</comment>
    <!--
    Magic number listing :
    * next generated ACL_CLASS.ID : 8 (ActionWordLibrary)
    * CLASS_ID of test case library : 3

    The following script will insert the new ACL_CLASS (the action word library).

    Then it will batch insert in ACL_GROUP_PERMISSION, for each user profile,
    the same permission for action word libraries than it enjoys for the test case libraries
    except for delete permission (8) which is just for project manager (5).
    -->
    <sql>
      insert into ACL_CLASS(ID, CLASSNAME)
      values(8, 'org.squashtest.tm.domain.actionword.ActionWordLibrary');

      insert into ACL_GROUP_PERMISSION(ACL_GROUP_ID, PERMISSION_MASK, CLASS_ID)
      select AGP2.ACL_GROUP_ID, AGP2.PERMISSION_MASK, 8
      from ACL_GROUP_PERMISSION AGP2
      where (CLASS_ID = 3 and PERMISSION_MASK != 8) or (CLASS_ID = 3 and ACL_GROUP_ID = 5);
    </sql>

    <comment>Add foreign key to the library in a project</comment>

    <addColumn tableName="PROJECT">
      <column name="AWL_ID" type="BIGINT">
        <constraints references="ACTION_WORD_LIBRARY(AWL_ID)" foreignKeyName="fk_project_awl" />
      </column>
    </addColumn>

    <createIndex tableName="PROJECT" indexName="idx_fk_project_awl">
      <column name="AWL_ID" />
    </createIndex>

    <comment>Create one action word library for each existing project</comment>

    <!--
    This script will create
    - one ActionWordLibrary per project,
    - one attachment list per library
    - bind them together
    - the corresponding entry in ACL_OBJECT_IDENTITY
    - and finally the corresponding entries in ACL_RESPONSIBILITY_SCOPE_ENTRY

    In the following queries the IDs for the attachment lists and AWL libraries are imposed (rather than
    autogenerated) in order to simplify the operations. In particular the AWL ids are set to be the same
    than the projects they depend on.
    -->

    <sql>
      <![CDATA[
      -- Create the libraries --

      insert into ACTION_WORD_LIBRARY (AWL_ID)
        select p.PROJECT_ID
        from PROJECT p;

      -- Attachments, Step 1 --
      -- Create a ranking table, akin to what would ROW_NUMBER() order by id desc would say --

      create table AWL_RANK as
        select awl.awl_id,
               count(awl2.awl_id) as ranking
        from ACTION_WORD_LIBRARY awl,
             ACTION_WORD_LIBRARY awl2
        where awl.awl_id <= awl2.awl_id
        group by awl.awl_id
        order by ranking asc;


      -- Attachments, Step 2 --
      -- Create a table that pairs library ids with predictable, consecutive attachment_list_ids using the rank
      -- calculated earlier --

      create table AWL_ATTACHMENT_LIST_PAIRING as
        select awl_rank.awl_id,
               (select max(al.attachment_list_id) from ATTACHMENT_LIST al) + awl_rank.ranking as attachment_list_id
        from AWL_RANK awl_rank;


      -- Attachments, Step 3 --
      -- Insert the attachment lists and update fk in the action word library --

      insert into ATTACHMENT_LIST(ATTACHMENT_LIST_ID)
        select pair.attachment_list_id
        from AWL_ATTACHMENT_LIST_PAIRING pair;

      update ACTION_WORD_LIBRARY awl
      set ATTACHMENT_LIST_ID = (select pair.attachment_list_id
                                from AWL_ATTACHMENT_LIST_PAIRING pair
                                where pair.awl_id = awl.awl_id);

      -- Attachments, Step 4 and final --
      -- Drop the temporary tables --

      drop table AWL_ATTACHMENT_LIST_PAIRING;

      drop table AWL_RANK;

      -- Bind the project to the AWL library --

      update PROJECT P
      set AWL_ID = PROJECT_ID;

      -- Insert the acl object identities --

      insert into ACL_OBJECT_IDENTITY(IDENTITY, CLASS_ID)
        select awl.awl_id, 8 from ACTION_WORD_LIBRARY awl;

      -- Add the user/team permissions in ACL_RESPONSIBILITY_SCOPE_ENTRY
      -- Each user will receive the same acl_group on each action word library than on the project it depends on
      -- (this last sentence is the idea behind the auto join on acl_object_identity in this query) --

      insert into ACL_RESPONSIBILITY_SCOPE_ENTRY(party_id, acl_group_id, object_identity_id)
        select distinct arse.party_id, arse.acl_group_id, awl_oid.id
        from ACL_RESPONSIBILITY_SCOPE_ENTRY arse
        inner join ACL_OBJECT_IDENTITY oid on (arse.object_identity_id = oid.id and oid.class_id = 1)
        inner join ACL_OBJECT_IDENTITY awl_oid on (oid.identity = awl_oid.identity and awl_oid.class_id = 8);

    ]]>
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-302-action-word-workspace-2" author="jlor">
    <comment>Create action word library node table</comment>

    <createTable tableName="ACTION_WORD_LIBRARY_NODE">
      <column name="AWLN_ID" type="BIGINT" autoIncrement="true" remarks="The auto-generated id">
        <constraints primaryKey="true" nullable="false" primaryKeyName="PK_ACTION_WORD_LIBRARY_NODE" />
      </column>

      <column name="NAME" type="VARCHAR(255)"/>

      <column name="ENTITY_TYPE" type="VARCHAR(50)"/>

      <column name="ENTITY_ID" type="BIGINT"/>

      <column name="AWL_ID" type="BIGINT" remarks="Foreign key to the ACTION_WORD_LIBRARY">
        <constraints references="ACTION_WORD_LIBRARY(AWL_ID)" nullable="true" foreignKeyName="fk_awln_awl" />
      </column>
    </createTable>

    <createIndex tableName="ACTION_WORD_LIBRARY_NODE" indexName="idx_action_word_library_node">
      <column name="AWLN_ID" />
    </createIndex>

    <createIndex tableName="ACTION_WORD_LIBRARY_NODE" indexName="idx_fk_awln_awl">
      <column name="AWL_ID" />
    </createIndex>

    <comment>Create one action word library node for each library created</comment>

    <sql>
      insert into ACTION_WORD_LIBRARY_NODE (AWL_ID, ENTITY_ID, ENTITY_TYPE)
      select AWL_ID, AWL_ID, 'LIBRARY'
      from ACTION_WORD_LIBRARY;

      update ACTION_WORD_LIBRARY_NODE
      set NAME = (select p.NAME from PROJECT p where ENTITY_ID = p.AWL_ID)
      where ENTITY_TYPE = 'LIBRARY';
    </sql>

    <comment>Create action word library node relationship table</comment>

    <createTable tableName="AWLN_RELATIONSHIP">

      <column name="ANCESTOR_ID" type="BIGINT" remarks="Foreign key to parent node">
        <constraints nullable="true" foreignKeyName="fk_awln_relationship_ancestor" references="ACTION_WORD_LIBRARY_NODE(AWLN_ID)" />
      </column>

      <column name="DESCENDANT_ID" type="BIGINT" remarks="Foreign key to child node">
        <constraints nullable="false" foreignKeyName="fk_awln_relationship_descendant" references="ACTION_WORD_LIBRARY_NODE(AWLN_ID)" />
      </column>

      <column name="CONTENT_ORDER" type="BIGINT" remarks="Order in its parent node">
      </column>
    </createTable>

    <createIndex tableName="AWLN_RELATIONSHIP" indexName="idx_awln_relationship_descendant">
      <column name="DESCENDANT_ID" />
    </createIndex>

    <createIndex tableName="AWLN_RELATIONSHIP" indexName="idx_awln_relationship_ancestor">
      <column name="ANCESTOR_ID" />
    </createIndex>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-302-action-word-workspace-3" author="jlor" dbms="postgresql">
    <comment>Reset postgresql sequences</comment>

    <sql>
      select setval('action_word_library_awl_id_seq', (select MAX(AWL_ID) from ACTION_WORD_LIBRARY));
      select setval('attachment_list_attachment_list_id_seq', (select MAX(ATTACHMENT_LIST_ID) from ATTACHMENT_LIST));
      select setval('acl_object_identity_id_seq', (SELECT MAX(ID) from ACL_OBJECT_IDENTITY));
      select setval('acl_responsibility_scope_entry_id_seq', (select MAX(ID) from ACL_RESPONSIBILITY_SCOPE_ENTRY));
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-794-auditable-automated-suite" author="aguilhem">
    <comment>Make Automated Suite auditable</comment>

    <addColumn tableName="AUTOMATED_SUITE">
      <column name="CREATED_BY" type="VARCHAR(50)"/>
    </addColumn>

    <addColumn tableName="AUTOMATED_SUITE">
      <column name="CREATED_ON" type="DATETIME"/>
    </addColumn>

    <addColumn tableName="AUTOMATED_SUITE">
      <column name="LAST_MODIFIED_BY" type="VARCHAR(50)" defaultValue="NULL" />
    </addColumn>

    <addColumn tableName="AUTOMATED_SUITE">
      <column name="LAST_MODIFIED_ON" type="DATETIME" defaultValue="NULL" />
    </addColumn>

  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-794-automated-suite-migration-postgres" author="aguilhem" dbms="postgresql">
    <comment>Add audit data on automated suite for postgresql</comment>

    <sql>
      UPDATE AUTOMATED_SUITE asuite
      SET CREATED_ON = exec.CREATED_ON,
          CREATED_BY = exec.CREATED_BY,
          LAST_MODIFIED_BY = exec.LAST_MODIFIED_BY,
          LAST_MODIFIED_ON = exec.LAST_MODIFIED_ON
      FROM (
        select ex.CREATED_ON, ex.CREATED_BY, ex.LAST_MODIFIED_BY, ex.LAST_MODIFIED_ON, ext.SUITE_ID
        from AUTOMATED_EXECUTION_EXTENDER ext
        inner join EXECUTION ex on ext.MASTER_EXECUTION_ID = ex.EXECUTION_ID
        order by ex.LAST_MODIFIED_ON desc) AS exec
      WHERE exec.SUITE_ID = asuite.SUITE_ID;

      UPDATE AUTOMATED_SUITE asuite
      SET CREATED_ON = '2000-01-01 00:00:00+02',
      CREATED_BY = 'admin'
      WHERE asuite.CREATED_ON IS NULL;

      ALTER TABLE AUTOMATED_SUITE ALTER COLUMN CREATED_ON SET NOT NULL;
      ALTER TABLE AUTOMATED_SUITE ALTER COLUMN CREATED_BY SET NOT NULL;
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-794-automated-suite-migration-mysql" author="aguilhem" dbms="mysql">
    <comment>Add audit data on automated suite for mysql</comment>

    <sql>
      UPDATE AUTOMATED_SUITE asuite
      INNER JOIN (
        select ex.CREATED_ON, ex.CREATED_BY, ex.LAST_MODIFIED_BY, ex.LAST_MODIFIED_ON, ext.SUITE_ID
        from AUTOMATED_EXECUTION_EXTENDER ext
        inner join EXECUTION ex on ext.MASTER_EXECUTION_ID = ex.EXECUTION_ID
        order by ex.LAST_MODIFIED_ON desc
      ) AS exec
      ON exec.SUITE_ID = asuite.SUITE_ID
      SET asuite.CREATED_ON = exec.CREATED_ON,
          asuite.CREATED_BY = exec.CREATED_BY,
          asuite.LAST_MODIFIED_BY = exec.LAST_MODIFIED_BY,
          asuite.LAST_MODIFIED_ON = exec.LAST_MODIFIED_ON;

      UPDATE AUTOMATED_SUITE
      SET CREATED_ON = '2000-01-01 00:00:00.0',
      CREATED_BY = 'admin'
      WHERE CREATED_ON IS NULL;

      ALTER TABLE AUTOMATED_SUITE MODIFY CREATED_ON DATETIME NOT NULL;
      ALTER TABLE AUTOMATED_SUITE MODIFY CREATED_BY VARCHAR(50) NOT NULL;
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-794-automated-suite-migration-h2" author="aguilhem" dbms="h2">
    <comment>Add audit data on automated suite for h2</comment>

    <sql>
      UPDATE AUTOMATED_SUITE asuite
      SET (CREATED_ON, CREATED_BY, LAST_MODIFIED_BY, LAST_MODIFIED_ON)=
      (select ex.CREATED_ON, ex.CREATED_BY, ex.LAST_MODIFIED_BY, ex.LAST_MODIFIED_ON
      from AUTOMATED_EXECUTION_EXTENDER ext
      inner join EXECUTION ex on ext.MASTER_EXECUTION_ID = ex.EXECUTION_ID
      where ext.SUITE_ID = asuite.SUITE_ID
      order by ex.LAST_MODIFIED_ON desc
      limit 1);

      UPDATE AUTOMATED_SUITE
      SET CREATED_ON = '2000-01-01 00:00:00.0',
      CREATED_BY = 'admin'
      WHERE CREATED_ON IS NULL;

      ALTER TABLE AUTOMATED_SUITE MODIFY CREATED_ON TIMESTAMP NOT NULL;
      ALTER TABLE AUTOMATED_SUITE MODIFY CREATED_BY VARCHAR(50) NOT NULL;
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-795" author="aguilhem">
  <comment>Adds a execution status field to the automated suites</comment>
  <addColumn tableName="AUTOMATED_SUITE">
    <column name="EXECUTION_STATUS" type="VARCHAR(255)" defaultValue="READY">
    </column>
  </addColumn>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-795-migration-mysql" author="aguilhem" dbms="mysql">
    <comment>Compute preexisting automated suites status for mysql</comment>
    <sql>
      UPDATE AUTOMATED_SUITE asuite
      INNER JOIN
      (
        SELECT automated_suite.SUITE_ID,
              blocked_count.counter as blocked_count,
              untestable_count.counter as untestable_count,
              settled_count.counter as settled_count,
              failure_count.counter as failure_count,
              success_count.counter as success_count,
              running_count.counter as running_count,
              total_count.counter as total_count
        FROM AUTOMATED_SUITE as automated_suite
        LEFT JOIN
          (SELECT ext.SUITE_ID, count(ext.SUITE_ID) as counter
          FROM AUTOMATED_EXECUTION_EXTENDER ext
          INNER JOIN EXECUTION ex ON ext.MASTER_EXECUTION_ID = ex.EXECUTION_ID
          AND ex.EXECUTION_STATUS IN ('BLOCKED', 'ERROR', 'NOT_RUN')
          GROUP BY ext.SUITE_ID) as blocked_count
        ON automated_suite.SUITE_ID = blocked_count.SUITE_ID
        LEFT JOIN
          (SELECT ext.SUITE_ID, count(ext.SUITE_ID) as counter
          FROM AUTOMATED_EXECUTION_EXTENDER ext
          INNER JOIN EXECUTION ex ON ext.MASTER_EXECUTION_ID = ex.EXECUTION_ID
          AND ex.EXECUTION_STATUS IN ('UNTESTABLE', 'NOT_FOUND')
          GROUP BY ext.SUITE_ID) as untestable_count
        ON automated_suite.SUITE_ID = untestable_count.SUITE_ID
        LEFT JOIN
          (SELECT ext.SUITE_ID, count(ext.SUITE_ID) as counter
          FROM AUTOMATED_EXECUTION_EXTENDER ext
          INNER JOIN EXECUTION ex ON ext.MASTER_EXECUTION_ID = ex.EXECUTION_ID
          AND ex.EXECUTION_STATUS IN ('SETTLED', 'UNTESTABLE', 'NOT_FOUND')
          GROUP BY ext.SUITE_ID) as settled_count
        ON automated_suite.SUITE_ID = settled_count.SUITE_ID
        LEFT JOIN
          (SELECT ext.SUITE_ID, count(ext.SUITE_ID) as counter
          FROM AUTOMATED_EXECUTION_EXTENDER ext
          INNER JOIN EXECUTION ex ON ext.MASTER_EXECUTION_ID = ex.EXECUTION_ID
          AND ex.EXECUTION_STATUS = 'FAILURE'
          GROUP BY ext.SUITE_ID) as failure_count
        ON automated_suite.SUITE_ID = failure_count.SUITE_ID
        LEFT JOIN
          (SELECT ext.SUITE_ID, count(ext.SUITE_ID) as counter
          FROM AUTOMATED_EXECUTION_EXTENDER ext
          INNER JOIN EXECUTION ex ON ext.MASTER_EXECUTION_ID = ex.EXECUTION_ID
          AND ex.EXECUTION_STATUS IN ('SUCCESS', 'UNTESTABLE', 'SETTLED', 'NOT_FOUND', 'WARNING')
          GROUP BY ext.SUITE_ID) as success_count
        ON automated_suite.SUITE_ID = success_count.SUITE_ID
        LEFT JOIN
          (SELECT ext.SUITE_ID, count(ext.SUITE_ID) as counter
          FROM AUTOMATED_EXECUTION_EXTENDER ext
          INNER JOIN EXECUTION ex ON ext.MASTER_EXECUTION_ID = ex.EXECUTION_ID
          AND ex.EXECUTION_STATUS IN ('SUCCESS', 'UNTESTABLE', 'SETTLED', 'NOT_FOUND', 'WARNING')
          GROUP BY ext.SUITE_ID) as running_count
        ON automated_suite.SUITE_ID = running_count.SUITE_ID
        LEFT JOIN
          (SELECT ext.SUITE_ID, count(ext.SUITE_ID) as counter
          FROM AUTOMATED_EXECUTION_EXTENDER ext
          INNER JOIN EXECUTION ex ON ext.MASTER_EXECUTION_ID = ex.EXECUTION_ID
          GROUP BY ext.SUITE_ID) as total_count
          ON automated_suite.SUITE_ID = total_count.SUITE_ID
      ) as count_table
      ON asuite.SUITE_ID = count_table.SUITE_ID
      SET asuite.EXECUTION_STATUS = (
        CASE
          WHEN (count_table.blocked_count IS NOT NULL AND count_table.blocked_count > 0) THEN 'BLOCKED'
          WHEN (count_table.untestable_count IS NOT NULL AND count_table.untestable_count = count_table.total_count) THEN 'UNTESTABLE'
          WHEN (count_table.settled_count IS NOT NULL AND count_table.settled_count = count_table.total_count) THEN 'SETTLED'
          WHEN (count_table.failure_count IS NOT NULL AND count_table.failure_count > 0) THEN 'FAILURE'
          WHEN (count_table.success_count IS NOT NULL AND count_table.success_count = count_table.total_count) THEN 'SUCCESS'
          WHEN (count_table.running_count IS NOT NULL AND count_table.running_count > 0) THEN 'RUNNING'
          ELSE 'READY'
        END
      )
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-795-migration-mysql" author="aguilhem" dbms="postgresql">
    <comment>Compute preexisting automated suites status for postgres</comment>
    <sql>
      UPDATE AUTOMATED_SUITE asuite
      SET EXECUTION_STATUS = (
        CASE
          WHEN (count_table.blocked_count IS NOT NULL AND count_table.blocked_count > 0) THEN 'BLOCKED'
          WHEN (count_table.untestable_count IS NOT NULL AND count_table.untestable_count = count_table.total_count) THEN 'UNTESTABLE'
          WHEN (count_table.settled_count IS NOT NULL AND count_table.settled_count = count_table.total_count) THEN 'SETTLED'
          WHEN (count_table.failure_count IS NOT NULL AND count_table.failure_count > 0) THEN 'FAILURE'
          WHEN (count_table.success_count IS NOT NULL AND count_table.success_count = count_table.total_count) THEN 'SUCCESS'
          WHEN (count_table.running_count IS NOT NULL AND count_table.running_count > 0) THEN 'RUNNING'
          ELSE 'READY'
        END
      )
      FROM
      (
        SELECT automated_suite.SUITE_ID,
              blocked_count.counter as blocked_count,
              untestable_count.counter as untestable_count,
              settled_count.counter as settled_count,
              failure_count.counter as failure_count,
              success_count.counter as success_count,
              running_count.counter as running_count,
              total_count.counter as total_count
        FROM AUTOMATED_SUITE as automated_suite
        LEFT JOIN
          (SELECT ext.SUITE_ID, count(ext.SUITE_ID) as counter
          FROM AUTOMATED_EXECUTION_EXTENDER ext
          INNER JOIN EXECUTION ex ON ext.MASTER_EXECUTION_ID = ex.EXECUTION_ID
          AND ex.EXECUTION_STATUS IN ('BLOCKED', 'ERROR', 'NOT_RUN')
          GROUP BY ext.SUITE_ID) as blocked_count
        ON automated_suite.SUITE_ID = blocked_count.SUITE_ID
        LEFT JOIN
          (SELECT ext.SUITE_ID, count(ext.SUITE_ID) as counter
          FROM AUTOMATED_EXECUTION_EXTENDER ext
          INNER JOIN EXECUTION ex ON ext.MASTER_EXECUTION_ID = ex.EXECUTION_ID
          AND ex.EXECUTION_STATUS IN ('UNTESTABLE', 'NOT_FOUND')
          GROUP BY ext.SUITE_ID) as untestable_count
        ON automated_suite.SUITE_ID = untestable_count.SUITE_ID
        LEFT JOIN
          (SELECT ext.SUITE_ID, count(ext.SUITE_ID) as counter
          FROM AUTOMATED_EXECUTION_EXTENDER ext
          INNER JOIN EXECUTION ex ON ext.MASTER_EXECUTION_ID = ex.EXECUTION_ID
          AND ex.EXECUTION_STATUS IN ('SETTLED', 'UNTESTABLE', 'NOT_FOUND')
          GROUP BY ext.SUITE_ID) as settled_count
        ON automated_suite.SUITE_ID = settled_count.SUITE_ID
        LEFT JOIN
          (SELECT ext.SUITE_ID, count(ext.SUITE_ID) as counter
          FROM AUTOMATED_EXECUTION_EXTENDER ext
          INNER JOIN EXECUTION ex ON ext.MASTER_EXECUTION_ID = ex.EXECUTION_ID
          AND ex.EXECUTION_STATUS = 'FAILURE'
          GROUP BY ext.SUITE_ID) as failure_count
        ON automated_suite.SUITE_ID = failure_count.SUITE_ID
        LEFT JOIN
          (SELECT ext.SUITE_ID, count(ext.SUITE_ID) as counter
          FROM AUTOMATED_EXECUTION_EXTENDER ext
          INNER JOIN EXECUTION ex ON ext.MASTER_EXECUTION_ID = ex.EXECUTION_ID
          AND ex.EXECUTION_STATUS IN ('SUCCESS', 'UNTESTABLE', 'SETTLED', 'NOT_FOUND', 'WARNING')
          GROUP BY ext.SUITE_ID) as success_count
        ON automated_suite.SUITE_ID = success_count.SUITE_ID
        LEFT JOIN
          (SELECT ext.SUITE_ID, count(ext.SUITE_ID) as counter
          FROM AUTOMATED_EXECUTION_EXTENDER ext
          INNER JOIN EXECUTION ex ON ext.MASTER_EXECUTION_ID = ex.EXECUTION_ID
          AND ex.EXECUTION_STATUS IN ('SUCCESS', 'UNTESTABLE', 'SETTLED', 'NOT_FOUND', 'WARNING')
          GROUP BY ext.SUITE_ID) as running_count
        ON automated_suite.SUITE_ID = running_count.SUITE_ID
        LEFT JOIN
          (SELECT ext.SUITE_ID, count(ext.SUITE_ID) as counter
          FROM AUTOMATED_EXECUTION_EXTENDER ext
          INNER JOIN EXECUTION ex ON ext.MASTER_EXECUTION_ID = ex.EXECUTION_ID
          GROUP BY ext.SUITE_ID) as total_count
        ON automated_suite.SUITE_ID = total_count.SUITE_ID
      ) as count_table
      WHERE count_table.SUITE_ID = asuite.SUITE_ID;
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-896-add-indexes-for-search-sort-columns" author="jprioux">
    <comment>add indexes on default search sort columns</comment>


    <createIndex tableName="PROJECT" indexName="idx_project_name">
      <column name="NAME" />
    </createIndex>
    <createIndex tableName="TEST_CASE" indexName="idx_tc_reference">
      <column name="REFERENCE" />
    </createIndex>
    <createIndex tableName="TEST_CASE" indexName="idx_tc_importance">
      <column name="IMPORTANCE" />
    </createIndex>

    <createIndex tableName="REQUIREMENT_VERSION" indexName="idx_req_reference">
      <column name="REFERENCE" />
    </createIndex>
    <createIndex tableName="REQUIREMENT_VERSION" indexName="idx_req_status">
      <column name="REQUIREMENT_STATUS" />
    </createIndex>
    <createIndex tableName="REQUIREMENT_VERSION" indexName="idx_req_criticality">
      <column name="CRITICALITY" />
    </createIndex>

    <createIndex tableName="ITERATION" indexName="idx_iteration_name">
      <column name="NAME" />
    </createIndex>
    <createIndex tableName="CAMPAIGN_LIBRARY_NODE" indexName="idx_cln_name">
      <column name="NAME" />
    </createIndex>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-891" author="aguilhem">
    <comment>Automated Suite can be directly linked to an iteration or a test suite</comment>
    <addColumn tableName="AUTOMATED_SUITE">
      <column name="ITERATION_ID" type="BIGINT">
        <constraints references="ITERATION(ITERATION_ID)" nullable="true" foreignKeyName="fk_automated_suite_iteration" />
      </column>
      <column name="TEST_SUITE_ID" type="BIGINT">
        <constraints references="TEST_SUITE(ID)" nullable="true" foreignKeyName="fk_automated_suite_test_suite" />
      </column>
    </addColumn>
  </changeSet>


  <changeSet id="tm-1.22.0-SQUASH-291-bdd-impl-techno-and-language" author="jlor">
    <addColumn tableName="PROJECT">
      <column name="BDD_IMPLEMENTATION_TECHNOLOGY" type="VARCHAR(30)" defaultValue="CUCUMBER">
        <constraints nullable="false" />
      </column>
      <column name="BDD_SCRIPT_LANGUAGE" type="VARCHAR(30)" defaultValue="ENGLISH">
        <constraints nullable="false" />
      </column>
    </addColumn>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-306-create-closure-table" author="mqtran">
    <!-- CLOSURE -->
    <comment>
      closure table for action word library nodes. Its content is set and modified by 4 triggers
    </comment>

    <createTable tableName="AWLN_RELATIONSHIP_CLOSURE">

      <column name="ANCESTOR_ID" type="BIGINT"
              remarks="cle etrangere vers le noeud parent. La relation est parfois d'un noeud vers lui meme.">
        <constraints nullable="false" foreignKeyName="fk_awln_relationship_clos_anc"
                     references="ACTION_WORD_LIBRARY_NODE(AWLN_ID)" />
      </column>

      <column name="DESCENDANT_ID" type="BIGINT"
              remarks="cle etrangere vers l'element fils. La relation est parfois d'un noeud vers lui meme.">
        <constraints nullable="false" foreignKeyName="fk_awln_relationship_clos_desc"
                     references="ACTION_WORD_LIBRARY_NODE(AWLN_ID)" />
      </column>

      <column name="DEPTH" type="SMALLINT"
              remarks="stores how deep is the descendant element nested in the subtree of the ancestor element">
        <constraints nullable="false" />
      </column>
    </createTable>

    <createIndex tableName="AWLN_RELATIONSHIP_CLOSURE"
                 indexName="idx_awln_relationship_clos_desc">
      <column name="DESCENDANT_ID" />
    </createIndex>

    <createIndex tableName="AWLN_RELATIONSHIP_CLOSURE"
                 indexName="idx_awln_relationship_clos_anc">
      <column name="ANCESTOR_ID" />
    </createIndex>

    <addUniqueConstraint tableName="AWLN_RELATIONSHIP_CLOSURE" columnNames="ANCESTOR_ID, DESCENDANT_ID"/>

    <!-- CLOSURE-->
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-306-closure-postgresql-trigger" author="mqtran" dbms="postgresql">
    <comment>postgresql-triggers for AWLN_RELATIONSHIP_CLOSURE table</comment>

    <!-- after insertion of a node : create auto reference in the closure table -->
    <createProcedure>
      drop trigger if exists ins_awln_after on ACTION_WORD_LIBRARY_NODE;
      drop function if exists ins_awln_after();
      create function ins_awln_after() returns trigger as $ins_awln_after$
      begin
      insert into AWLN_RELATIONSHIP_CLOSURE
      values (new.awln_id, new.awln_id, 0);
      return new;
      end;
      $ins_awln_after$ language plpgsql;

      create trigger ins_awln_after after insert on ACTION_WORD_LIBRARY_NODE
      for each row execute procedure ins_awln_after();

    </createProcedure>


    <!-- before suppression of a node : remove auto reference from the closure table -->
    <createProcedure>
      drop trigger if exists del_awln_before on ACTION_WORD_LIBRARY_NODE;
      drop function if exists del_awln_before();
      create function del_awln_before() returns trigger as $del_awln_before$
      begin
      delete from AWLN_RELATIONSHIP_CLOSURE
      where ancestor_id = old.awln_id
      and descendant_id = old.awln_id;
      return old;
      end;
      $del_awln_before$ language plpgsql;

      create trigger del_awln_before before delete on ACTION_WORD_LIBRARY_NODE
      for each row execute procedure del_awln_before();

    </createProcedure>


    <!-- when two nodes are attached : attach the subtrees as well. -->
    <createProcedure>
      drop trigger if exists attach_awln_after on AWLN_RELATIONSHIP;
      drop function if exists attach_awln_after();
      create function attach_awln_after() returns trigger as $attach_awln_after$
      begin
      insert into AWLN_RELATIONSHIP_CLOSURE
      select c1.ancestor_id, c2.descendant_id, c1.depth + c2.depth + 1
      from AWLN_RELATIONSHIP_CLOSURE c1
      cross join AWLN_RELATIONSHIP_CLOSURE c2
      where c1.descendant_id = new.ancestor_id
      and c2.ancestor_id = new.descendant_id;
      return new;
      end;
      $attach_awln_after$ language plpgsql;

      create trigger attach_awln_after after insert on AWLN_RELATIONSHIP
      for each row execute procedure attach_awln_after();

    </createProcedure>


    <!-- when two nodes are detached : detach the subtrees as well -->
    <createProcedure>
      drop trigger if exists detach_awln_before on AWLN_RELATIONSHIP;
      drop function if exists detach_awln_before();
      create function detach_awln_before() returns trigger as $detach_awln_before$
      begin
      delete from AWLN_RELATIONSHIP_CLOSURE
      where descendant_id in ( select descendant_id from AWLN_RELATIONSHIP_CLOSURE where ancestor_id = old.descendant_id )
      and ancestor_id not in ( select descendant_id from AWLN_RELATIONSHIP_CLOSURE where ancestor_id = old.descendant_id )
      ;
      return old;
      end;
      $detach_awln_before$ language plpgsql;

      create trigger detach_awln_before before delete on AWLN_RELATIONSHIP
      for each row execute procedure detach_awln_before();

    </createProcedure>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-306-closure-h2-trigger" author="mqtran" dbms="h2">

    <comment>h2-triggers for AWLN_RELATIONSHIP_CLOSURE table</comment>

    <!-- after insertion of a node : create auto reference in the closure table -->
    <sql>
      create trigger ins_awln_after after insert on
      ACTION_WORD_LIBRARY_NODE
      for each row call
      "org.squashtest.csp.h2.triggers.AWLNAfterInsert";
    </sql>


    <!-- before suppression of a cl node : remove auto reference from the closure table -->
    <sql>
      create trigger del_awln_before before delete on
      ACTION_WORD_LIBRARY_NODE
      for each row call
      "org.squashtest.csp.h2.triggers.AWLNBeforeDelete";
    </sql>


    <!-- when two nodes are attached : attach the subtrees as well. -->
    <sql>
      create trigger attach_awln_after after insert on AWLN_RELATIONSHIP
      for each row call "org.squashtest.csp.h2.triggers.AWLNAfterAttach";
    </sql>


    <!-- when two cl nodes are detached : detach the subtrees as well -->
    <sql>
      create trigger detach_awln_before before delete on
      AWLN_RELATIONSHIP
      for each row call
      "org.squashtest.csp.h2.triggers.AWLNBeforeDetach";
    </sql>

  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-306-closure-mysql-trigger" author="mqtran" dbms="mysql">
    <comment>mysql-triggers for AWLN_RELATIONSHIP_CLOSURE table</comment>

    <!-- after insertion of a node : create auto reference in the closure table -->
    <sql>
      create trigger ins_awln_after after insert on
      ACTION_WORD_LIBRARY_NODE
      for each row insert ignore into
      AWLN_RELATIONSHIP_CLOSURE values (new.awln_id, new.awln_id, 0);
    </sql>


    <!-- before suppression of a cl node : remove auto reference from the closure table -->
    <sql>
      create trigger del_awln_before before delete on
      ACTION_WORD_LIBRARY_NODE
      for each row delete from
      AWLN_RELATIONSHIP_CLOSURE where ancestor_id=old.awln_id and
      descendant_id=old.awln_id;
    </sql>


    <!-- when two nodes are attached : attach the subtrees as well. -->
    <sql>
      create trigger attach_awln_after after insert on AWLN_RELATIONSHIP
      for each row insert ignore into AWLN_RELATIONSHIP_CLOSURE
      select
      c1.ancestor_id, c2.descendant_id, c1.depth+c2.depth+1
      from
      AWLN_RELATIONSHIP_CLOSURE c1
      cross join AWLN_RELATIONSHIP_CLOSURE c2
      where c1.descendant_id = new.ancestor_id
      and c2.ancestor_id = new.descendant_id;
    </sql>


    <!-- when two cl nodes are detached : detach the subtrees as well -->
    <sql>
      create trigger detach_awln_before before delete on
      AWLN_RELATIONSHIP
      for each row delete clos1 from
      AWLN_RELATIONSHIP_CLOSURE clos1
      join AWLN_RELATIONSHIP_CLOSURE clos2
      on
      clos1.descendant_id=clos2.descendant_id
      left join
      AWLN_RELATIONSHIP_CLOSURE clos3
      on clos3.ancestor_id = clos2.ancestor_id
      and clos3.descendant_id = clos1.ancestor_id
      where
      clos2.ancestor_id = old.descendant_id
      and clos3.ancestor_id is null;
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-1107-aw-last-impl-techno-and-date" author="jlor">
    <addColumn tableName="ACTION_WORD">
      <column name="LAST_IMPLEMENTATION_TECHNOLOGY" type="VARCHAR(30)" remarks="Technology used for last implementation">
        <constraints nullable="true" />
      </column>
      <column name="LAST_IMPLEMENTATION_DATE" type="DATETIME" remarks="Date of last implementation">
        <constraints nullable="true" />
      </column>
    </addColumn>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-1284-migration-postgresql" author="qtran" dbms="postgresql">
    <comment>Remove all CUF values and CUF value options attaching to any deleted Test Case folder for postgresql</comment>
    <sql>
      DELETE FROM CUSTOM_FIELD_VALUE_OPTION
      WHERE cfv_id in (
        SELECT cfv.cfv_id FROM CUSTOM_FIELD_VALUE cfv
        LEFT JOIN TEST_CASE_FOLDER tcf
        ON cfv.bound_entity_id = tcf.tcln_id
        WHERE cfv.bound_entity_type = 'TESTCASE_FOLDER'
        AND tcf.tcln_id is null
      );

      DELETE FROM CUSTOM_FIELD_VALUE
      WHERE cfv_id in (
        SELECT cfv.cfv_id FROM CUSTOM_FIELD_VALUE cfv
        LEFT JOIN TEST_CASE_FOLDER tcf
        ON cfv.bound_entity_id = tcf.tcln_id
        WHERE cfv.bound_entity_type = 'TESTCASE_FOLDER'
        AND tcf.tcln_id is null
      );
    </sql>

    <comment>Remove all CUF values and CUF value options attaching to any deleted Campaign folder for postgresql</comment>
    <sql>
      DELETE FROM CUSTOM_FIELD_VALUE_OPTION
      WHERE cfv_id in (
        SELECT cfv.cfv_id FROM CUSTOM_FIELD_VALUE cfv
        LEFT JOIN CAMPAIGN_FOLDER cf
        ON cfv.bound_entity_id = cf.cln_id
        WHERE cfv.bound_entity_type = 'CAMPAIGN_FOLDER'
        AND cf.cln_id is null
      );

      DELETE FROM CUSTOM_FIELD_VALUE
      WHERE cfv_id in (
        SELECT cfv.cfv_id FROM CUSTOM_FIELD_VALUE cfv
        LEFT JOIN CAMPAIGN_FOLDER cf
        ON cfv.bound_entity_id = cf.cln_id
        WHERE cfv.bound_entity_type = 'CAMPAIGN_FOLDER'
        AND cf.cln_id is null
      );
    </sql>

    <comment>Remove all CUF values and CUF value options attaching to any deleted Requirement folder for postgresql</comment>
    <sql>
      DELETE FROM CUSTOM_FIELD_VALUE_OPTION
      WHERE cfv_id in (
        SELECT cfv.cfv_id FROM CUSTOM_FIELD_VALUE cfv
        LEFT JOIN REQUIREMENT_FOLDER rf
        ON cfv.bound_entity_id = rf.rln_id
        WHERE cfv.bound_entity_type = 'REQUIREMENT_FOLDER'
        AND rf.rln_id is null
      );

      DELETE FROM CUSTOM_FIELD_VALUE
      WHERE cfv_id in (
        SELECT cfv.cfv_id FROM CUSTOM_FIELD_VALUE cfv
        LEFT JOIN REQUIREMENT_FOLDER rf
        ON cfv.bound_entity_id = rf.rln_id
        WHERE cfv.bound_entity_type = 'REQUIREMENT_FOLDER'
        AND rf.rln_id is null
      );
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-1284-migration-mysql" author="qtran" dbms="mysql">
    <comment>Remove all CUF values and CUF value options attaching to any deleted Test Case folder for postgresql</comment>
    <sql>
      DELETE FROM CUSTOM_FIELD_VALUE_OPTION
      WHERE CFV_ID in (
        SELECT cfv.CFV_ID FROM CUSTOM_FIELD_VALUE cfv
        LEFT JOIN TEST_CASE_FOLDER tcf
        ON cfv.BOUND_ENTITY_ID = tcf.TCLN_ID
        WHERE cfv.BOUND_ENTITY_TYPE = 'TESTCASE_FOLDER'
        AND tcf.TCLN_ID is null
      );

      DELETE FROM CUSTOM_FIELD_VALUE
      WHERE CFV_ID in (
        SELECT cfv.CFV_ID
        FROM (SELECT * FROM CUSTOM_FIELD_VALUE WHERE BOUND_ENTITY_TYPE = 'TESTCASE_FOLDER') AS cfv
        LEFT JOIN TEST_CASE_FOLDER tcf
        ON cfv.BOUND_ENTITY_ID = tcf.TCLN_ID
        WHERE cfv.BOUND_ENTITY_TYPE = 'TESTCASE_FOLDER'
        AND tcf.TCLN_ID is null
      );
    </sql>

    <comment>Remove all CUF values and CUF value options attaching to any deleted Campaign folder for postgresql</comment>
    <sql>
      DELETE FROM CUSTOM_FIELD_VALUE_OPTION
      WHERE CFV_ID in (
        SELECT cfv.CFV_ID FROM CUSTOM_FIELD_VALUE cfv
        LEFT JOIN CAMPAIGN_FOLDER cf
        ON cfv.BOUND_ENTITY_ID = cf.CLN_ID
        WHERE cfv.BOUND_ENTITY_TYPE = 'CAMPAIGN_FOLDER'
        AND cf.CLN_ID is null
      );

      DELETE FROM CUSTOM_FIELD_VALUE
      WHERE CFV_ID in (
        SELECT cfv.CFV_ID
        FROM (SELECT * FROM CUSTOM_FIELD_VALUE WHERE BOUND_ENTITY_TYPE = 'CAMPAIGN_FOLDER') AS cfv
        LEFT JOIN CAMPAIGN_FOLDER cf
        ON cfv.BOUND_ENTITY_ID = cf.CLN_ID
        WHERE cfv.BOUND_ENTITY_TYPE = 'CAMPAIGN_FOLDER'
        AND cf.CLN_ID is null
      );
    </sql>

    <comment>Remove all CUF values and CUF value options attaching to any deleted Requirement folder for postgresql</comment>
    <sql>
      DELETE FROM CUSTOM_FIELD_VALUE_OPTION
      WHERE CFV_ID in (
        SELECT cfv.CFV_ID FROM CUSTOM_FIELD_VALUE cfv
        LEFT JOIN REQUIREMENT_FOLDER rf
        ON cfv.BOUND_ENTITY_ID = rf.RLN_ID
        WHERE cfv.BOUND_ENTITY_TYPE = 'REQUIREMENT_FOLDER'
        AND rf.RLN_ID is null
      );

      DELETE FROM CUSTOM_FIELD_VALUE
      WHERE CFV_ID in (
        SELECT cfv.CFV_ID
        FROM (SELECT * FROM CUSTOM_FIELD_VALUE WHERE BOUND_ENTITY_TYPE = 'REQUIREMENT_FOLDER') AS cfv
        LEFT JOIN REQUIREMENT_FOLDER rf
        ON cfv.BOUND_ENTITY_ID = rf.RLN_ID
        WHERE cfv.BOUND_ENTITY_TYPE = 'REQUIREMENT_FOLDER'
        AND rf.RLN_ID is null
      );
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-1466-test-case-source-code-repository-url" author="akatz">
    <addColumn tableName="TEST_CASE">
      <column name="SOURCE_CODE_REPOSITORY_URL" type="VARCHAR(255)" remarks="The url of the source code repository where the test lies">
        <constraints nullable="true" />
      </column>
      <column name="AUTOMATED_TEST_REFERENCE" type="VARCHAR(255)" remarks="The path to the test">
        <constraints nullable="true" />
      </column>
    </addColumn>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-1975-automation-server-migration-1" author="aguilhem">
    <comment>Preparation for data migration</comment>

    <createTable tableName="MIG_SQUASH_1975">
      <column name="OLD_ID" type="BIGINT">
        <constraints primaryKey="true" nullable="false"/>
      </column>
      <column name="NEW_ID" type="BIGINT">
      </column>
    </createTable>

    <dropForeignKeyConstraint baseTableName="TEST_AUTOMATION_PROJECT" constraintName="fk_ta_project_ta_server"/>
    <dropForeignKeyConstraint baseTableName="PROJECT" constraintName="tm_project_ta_server"/>

    <sql>
      INSERT INTO MIG_SQUASH_1975 (OLD_ID, NEW_ID)
      SELECT TEST_AUTOMATION_SERVER.SERVER_ID, max(THIRD_PARTY_SERVER.SERVER_ID)+TEST_AUTOMATION_SERVER.SERVER_ID as NEW_ID
      FROM TEST_AUTOMATION_SERVER, THIRD_PARTY_SERVER
      GROUP BY TEST_AUTOMATION_SERVER.SERVER_ID
      ORDER BY TEST_AUTOMATION_SERVER.SERVER_ID;

      INSERT INTO THIRD_PARTY_SERVER (SERVER_ID, NAME, URL, AUTH_POLICY, AUTH_PROTOCOL)
      SELECT MIG_SQUASH_1975.NEW_ID, TEST_AUTOMATION_SERVER.NAME, TEST_AUTOMATION_SERVER.BASE_URL, 'APP_LEVEL', 'BASIC_AUTH'
      FROM TEST_AUTOMATION_SERVER
      INNER JOIN MIG_SQUASH_1975 on MIG_SQUASH_1975.OLD_ID = TEST_AUTOMATION_SERVER.SERVER_ID
      ORDER BY TEST_AUTOMATION_SERVER.SERVER_ID;
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-1975-automation-server-migration-2-postgres" author="aguilhem" dbms="postgresql">
    <comment>Transform Test Automation Server to Third Party Server</comment>

    <sql>
      UPDATE TEST_AUTOMATION_SERVER
      SET SERVER_ID = mig.NEW_ID
      FROM MIG_SQUASH_1975 mig
      WHERE SERVER_ID = mig.OLD_ID;

      UPDATE TEST_AUTOMATION_PROJECT
      SET SERVER_ID = mig.NEW_ID
      FROM MIG_SQUASH_1975 mig
      WHERE SERVER_ID = mig.OLD_ID;

      UPDATE PROJECT
      SET TA_SERVER_ID = mig.NEW_ID
      FROM MIG_SQUASH_1975 mig
      WHERE TA_SERVER_ID = mig.OLD_ID
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-1975-automation-server-migration-2-mysql" author="aguilhem" dbms="mysql">
    <comment>Transform Test Automation Server to Third Party Server</comment>

    <sql>
      UPDATE TEST_AUTOMATION_SERVER ta_server
      INNER JOIN MIG_SQUASH_1975 mig
      ON ta_server.SERVER_ID = mig.OLD_ID
      SET ta_server.SERVER_ID = mig.NEW_ID;

      UPDATE TEST_AUTOMATION_PROJECT ta_proj
      INNER JOIN MIG_SQUASH_1975 mig
      ON ta_proj.SERVER_ID = mig.OLD_ID
      SET ta_proj.SERVER_ID = mig.NEW_ID;

      UPDATE PROJECT proj
      INNER JOIN MIG_SQUASH_1975 mig
      ON proj.TA_SERVER_ID = mig.OLD_ID
      SET proj.TA_SERVER_ID = mig.NEW_ID;
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-1975-automation-server-migration-2-h2" author="aguilhem" dbms="h2">
    <comment>Transform Test Automation Server to Third Party Server</comment>

    <sql>
      UPDATE TEST_AUTOMATION_SERVER ta_server
      SET ta_server.SERVER_ID =
      (select mig.NEW_ID
      from MIG_SQUASH_1975 mig
      where ta_server.SERVER_ID = mig.OLD_ID);

      UPDATE TEST_AUTOMATION_PROJECT ta_proj
      SET ta_proj.SERVER_ID =
      (select mig.NEW_ID
      from MIG_SQUASH_1975 mig
      where ta_proj.SERVER_ID = mig.OLD_ID);

      UPDATE PROJECT proj
      SET proj.TA_SERVER_ID =
      (select mig.NEW_ID
      from MIG_SQUASH_1975 mig
      where proj.TA_SERVER_ID = mig.OLD_ID);
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-1975-automation-server-migration-3" author="aguilhem">
    <comment>Finalisation of test automation server data migration</comment>

    <dropUniqueConstraint constraintName="UNI_AUTOTEST_SERVER" tableName="TEST_AUTOMATION_SERVER"/>
    <dropColumn tableName="TEST_AUTOMATION_SERVER" columnName="NAME"/>
    <dropColumn tableName="TEST_AUTOMATION_SERVER" columnName="BASE_URL"/>
    <dropColumn tableName="TEST_AUTOMATION_SERVER" columnName="LOGIN"/>
    <dropColumn tableName="TEST_AUTOMATION_SERVER" columnName="PASSWORD"/>

    <addForeignKeyConstraint baseColumnNames="SERVER_ID" baseTableName="TEST_AUTOMATION_PROJECT"
                             referencedColumnNames="SERVER_ID" referencedTableName="TEST_AUTOMATION_SERVER"
                             constraintName="fk_ta_project_ta_server"/>

    <addForeignKeyConstraint baseColumnNames="TA_SERVER_ID" baseTableName="PROJECT"
                             referencedColumnNames="SERVER_ID" referencedTableName="TEST_AUTOMATION_SERVER"
                             constraintName="tm_project_ta_server" />

    <addForeignKeyConstraint baseTableName="TEST_AUTOMATION_SERVER" baseColumnNames="SERVER_ID"
                             referencedTableName="THIRD_PARTY_SERVER" referencedColumnNames="SERVER_ID"
                             constraintName="fk_test_automation_server_third_party_server" onDelete="CASCADE"/>

    <dropTable tableName="MIG_SQUASH_1975"/>
  </changeSet>

  <changeSet author="aguilhem" id="tm-1.22.0-SQUASH-1975-automation-server-migration-4-h2" dbms="h2">
    <comment>For H2, remove the autoincrement on server_id</comment>
    <sql>
      alter table TEST_AUTOMATION_SERVER alter column SERVER_ID BIGINT NOT NULL;
    </sql>
  </changeSet>

  <changeSet author="aguilhem" id="tm-1.22.0-SQUASH-1975-automation-server-migration-4-mysql" dbms="mysql">
    <comment>For Mysql / Maria DB, remove the autoincrement on server_id</comment>

    <sql>
      set foreign_key_checks=0;
      alter table TEST_AUTOMATION_SERVER modify column SERVER_ID BIGINT not null;
      set foreign_key_checks=1;
    </sql>

  </changeSet>

  <changeSet author="aguilhem" id="tm-1.22.0-SQUASH-1975-automation-server-migration-4-postgres" dbms="postgresql">
    <comment>For PostGre, remove the autoincrement on server_id and reset the sequence for third_party_server</comment>

    <sql>
      alter table TEST_AUTOMATION_SERVER alter column SERVER_ID drop default;
      drop sequence if exists test_automation_server_server_id_seq;

      select setval('third_party_server_server_id_seq', (select max(SERVER_ID) from THIRD_PARTY_SERVER));
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-808-automated-suites-lifetime" author="jlor">
    <addColumn tableName="PROJECT">
      <column name="AUTOMATED_SUITES_LIFETIME" type="INT">
        <constraints nullable="true" />
      </column>
    </addColumn>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-2032-fix-null-description-in-requirement" author="jlor">
    <comment>Replace null descriptions by empty strings in requirements</comment>
    <sql>
      update RESOURCE
      set DESCRIPTION = ''
      where DESCRIPTION is NULL;
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-2106-automated-suite-attachment" author="aguilhem">
    <comment>Give possibility to AUTOMATED_SUITE to have ATTACHMENT</comment>
    <addColumn tableName="AUTOMATED_SUITE">
      <column name="ATTACHMENT_LIST_ID" type="BIGINT"
              remarks="foreign key to ATTACHMENT_LIST, entity dealing with attachment.">
        <constraints nullable="true"
                     references="ATTACHMENT_LIST(ATTACHMENT_LIST_ID)" foreignKeyName="fk_automated_suite_attachment_list" />
      </column>
    </addColumn>

  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-2106-automated-suite-attachment-2" author="aguilhem">
    <comment>Create one attachment list for each automated suite</comment>
    <sql>
      <![CDATA[

      -- attachments, step 1 :
      -- create a ranking table, akin to what would ROW_NUMBER() order by id desc would say

      create table ASUITE_RANK as
      select asuite.suite_id, count(asuite2.suite_id)  as ranking
      from AUTOMATED_SUITE asuite,
      AUTOMATED_SUITE asuite2
      where asuite.suite_id <= asuite2.suite_id
      group by asuite.suite_id
      order by ranking asc;


      -- attachments, step 2 :
      -- create a table that pairs suite ids with predictable, consecutive attachment_list_ids using the rank
      -- calculated earlier

      create table ASUITE_ATTACHLIST_PAIRING as
      select asuite.suite_id, (select max(al.attachment_list_id) from ATTACHMENT_LIST al) + asuite.ranking as attachment_list_id
      from ASUITE_RANK asuite;


      -- attachments, step 3 :
      -- insert the attachment lists and update fk in the automated suite
      insert into ATTACHMENT_LIST(ATTACHMENT_LIST_ID)
      select pair.attachment_list_id from ASUITE_ATTACHLIST_PAIRING pair;


      update AUTOMATED_SUITE asuite
      set ATTACHMENT_LIST_ID = (select pair.attachment_list_id from ASUITE_ATTACHLIST_PAIRING pair where pair.suite_id = asuite.suite_id);

      -- attachments, step 4 and final :
      -- drop the temporary tables

      drop table ASUITE_ATTACHLIST_PAIRING;

      drop table ASUITE_RANK;

    ]]>
    </sql>
  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-2106-automated-suite-attachment-3" author="aguilhem" dbms="postgresql">
    <comment>reset postgresql sequence</comment>

    <sql>
      select setval('attachment_list_attachment_list_id_seq', (select MAX(ATTACHMENT_LIST_ID) from ATTACHMENT_LIST));
    </sql>

  </changeSet>

  <changeSet id="tm-1.22.0-SQUASH-2141-automated-test-technology" author="aguilhem">
    <comment>create automated test technology table</comment>

    <createTable tableName="AUTOMATED_TEST_TECHNOLOGY">
      <column name="AT_TECHNOLOGY_ID" type="BIGINT" autoIncrement="true">
        <constraints primaryKey="true" nullable="false"/>
      </column>
      <column name="NAME" type="VARCHAR(50)">
        <constraints nullable="false"/>
      </column>
      <column name="ACTION_PROVIDER_KEY" type="VARCHAR(50)">
        <constraints nullable="false"/>
      </column>
    </createTable>

    <sql>
      insert into AUTOMATED_TEST_TECHNOLOGY(NAME, ACTION_PROVIDER_KEY)
      values ('Robot Framework', 'robotframework/execute@v1'),
      ('Cypress', 'cypress/execute@v1'),
      ('JUnit', 'junit/execute@v1')
    </sql>

    <addColumn tableName="TEST_CASE">
      <column name="AUTOMATED_TEST_TECHNOLOGY" type="BIGINT"
              remarks="foreign key to AUTOMATED_TEST_TECHNOLOGY">
        <constraints nullable="true"
                     references="AUTOMATED_TEST_TECHNOLOGY(AT_TECHNOLOGY_ID)" foreignKeyName="fk_test_case_automated_test_technology" />
      </column>
    </addColumn>

  </changeSet>

</databaseChangeLog>
