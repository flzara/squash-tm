/**
 *     This file is part of the Squashtest platform.
 *     Copyright (C) Henix, henix.fr
 *
 *     See the NOTICE file distributed with this work for additional
 *     information regarding copyright ownership.
 *
 *     This is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Lesser General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     this software is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public License
 *     along with this software.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.squashtest.tm.service.internal.repository

import com.querydsl.core.types.Expression
import com.querydsl.core.types.Order
import com.querydsl.core.types.OrderSpecifier
import com.querydsl.core.types.Predicate
import com.querydsl.core.types.dsl.CaseBuilder
import com.querydsl.core.types.dsl.ComparableOperation
import com.querydsl.core.types.dsl.EnumPath
import com.querydsl.core.types.dsl.Expressions
import com.querydsl.core.types.dsl.PathBuilder
import org.springframework.data.domain.Page
import org.springframework.data.domain.PageRequest
import org.springframework.data.domain.Pageable
import org.springframework.data.domain.Sort
import org.springframework.data.querydsl.QSort
import org.springframework.data.querydsl.binding.QuerydslPredicateBuilder
import org.squashtest.it.basespecs.DbunitDaoSpecification
import org.squashtest.tm.core.foundation.collection.ColumnFiltering
import org.squashtest.tm.core.foundation.collection.DefaultColumnFiltering
import org.squashtest.tm.domain.jpql.ExtendedHibernateQuery
import org.squashtest.tm.domain.tf.automationrequest.AutomationRequest
import org.squashtest.tm.domain.tf.automationrequest.AutomationRequestStatus
import org.squashtest.tm.domain.tf.automationrequest.QAutomationRequest
import org.unitils.dbunit.annotation.DataSet
import spock.unitils.UnitilsSupport

import javax.inject.Inject


@UnitilsSupport
class AutomationRequestDaoIT extends DbunitDaoSpecification{


	@Inject
	private AutomationRequestDao requestDao;

	@DataSet("AutomationRequestDaoIT.sample.xml")
	def "should retrieve a request by id"(){

		expect :
			requestDao.getOne(-1L) != null

	}


	@DataSet("AutomationRequestDaoIT.sample.xml")
	def "should retrieve a request by test case id"(){

		expect :
			requestDao.findByTestCaseId(-4L).requestStatus == AutomationRequestStatus.VALID


	}


	// ********************* paging, sorting and filtering *************************


	/*
	* Note : this test simply tests for the Spring Data Jpa autogenerated DAO. We can
	* assume that it works as expected, this test is present only for the sake of completion
	* and the satisfaction of another green bullet in the test report.
	*
	* The other tests will address the custom implementation of paged - sorted - filtered search.
	 */
	@DataSet("AutomationRequestDaoIT.sample.xml")
	def "should find sorted and paged with simple attributes "(){
		given :
		Pageable pageable = PageRequest.of(0, 10, Sort.Direction.ASC, "transmissionDate")

		when :
		Page<AutomationRequest> page = requestDao.findAll(pageable)

		then :
		page.totalElements == 4
		page.totalPages == 1

		page.content.collect {it.id } == [-2L, -1L, -4L, -3L]

	}


	@DataSet("AutomationRequestDaoIT.sample.xml")
	def "should find sorted, paged with a defined yet empty filter"(){
		given :
		Pageable pageable = PageRequest.of(1, 2, Sort.Direction.ASC, "transmissionDate")

		and :
		ColumnFiltering filter = new DefaultColumnFiltering();

		when :
		Page<AutomationRequest> page = requestDao.findAll(pageable, filter)

		then :
		page.totalElements == 4
		page.totalPages == 2

		page.content.collect {it.id } == [-4L, -3L]

	}

/*
	@DataSet("AutomationRequestDaoIT.sample.xml")
	def "should sort by workflow"(){

		given :
		QAutomationRequest qAutomationRequest = QAutomationRequest.automationRequest;
		EnumPath<AutomationRequestStatus> status = qAutomationRequest.requestStatus

		ComparableOperation<Integer> workflow = new CaseBuilder().when(status.eq(AutomationRequestStatus.VALID)).then(1)
																.when(status.eq(AutomationRequestStatus.TRANSMITTED)).then(2)
																.when(status.eq(AutomationRequestStatus.WORK_IN_PROGRESS)).then(3)
																.otherwise(4)

		ExtendedHibernateQuery<AutomationRequest> query = new ExtendedHibernateQuery<>(getSession())
																.from(qAutomationRequest)
																.orderBy(workflow.asc())

		when :

		def requests = query.fetch()

		then :
		requests.collect { it.id } == [-4L, -2L, -1L, -3L]
	}


	@DataSet("AutomationRequestDaoIT.sample.xml")
	def "should sort by workflow again"(){

		given :

		QAutomationRequest qAutomationRequest = QAutomationRequest.automationRequest;
		EnumPath<AutomationRequestStatus> status = qAutomationRequest.requestStatus

		ComparableOperation<Integer> workflow = new CaseBuilder().when(status.eq(AutomationRequestStatus.VALID)).then(1)
			.when(status.eq(AutomationRequestStatus.TRANSMITTED)).then(2)
			.when(status.eq(AutomationRequestStatus.WORK_IN_PROGRESS)).then(3)
			.otherwise(4)

		and:
		QSort sort = new QSort(workflow.asc())

		Pageable pageable = PageRequest.of(0, 10, sort)

		when :
		Page<AutomationRequest> page = requestDao.findAll(pageable)

		then :
		page.totalElements == 4
		page.totalPages == 1

		page.content.collect { it.id } == [-4L, -2L, -1L, -3L]
	}
*/

}
